---
title: "estacionariedad"
author: "Elio"
date: "July 20, 2018"
output: pdf_document
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE,
                      warning = FALSE, message = FALSE,
                      cache.path = "cache/estacionariedad_proof/",
                      fig.path = "fig/estacionariedad_proof/")

library(metR)
library(data.table)
library(ggplot2)
library(metR)
library(magrittr)
library(circular)
library(patchwork)

theme_elio <- theme_minimal(base_size = 11) +
   theme(
      # text = element_text(family = font_rc),
      legend.position = "bottom", legend.box = "vertical",
      panel.spacing.y = unit(5, "mm"),
      panel.spacing.x = unit(5, "mm"),
      legend.spacing = unit(2, "mm"),
      plot.margin = grid::unit(rep(3, 4), "mm"),
      legend.title = element_blank(),
      legend.box.spacing = unit(3, "mm"),
      legend.margin = margin(t = -5),
      panel.grid = element_line(color = "gray50", size = 0.2, linetype = 3),
      panel.ontop = TRUE)
theme_set(theme_elio)
guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
   guide_colorstrip(title.position = "top", title.hjust = 0.5,
                    barheight = height,
                    barwidth = width, ...)
}

```

# Demostración matemática de las propiedades de la estacionariedad

La idea es tener un fundamento matemático robusto para la medida de estacionariedad que estoy usando. La medida es la razón entre el promedio de la amplitud de las ondas 3 mensuales (AM) y la amplitud de la onda 3 del promedio las ondas mensuales (MA). Es decir, si la amplitud de una onda $w_i$ es $A(w_i)$, se tiene que 

$$
\begin{aligned}
\overline{A(w_i)} &= \frac{1}{N}\sum_{i=1}^{N}A(w_i) \\
A(\overline{w_i}) &= A \left ( \frac{1}{N}\sum_{i=1}^{N}w_i\right) 
\end{aligned}
$$

La primera expresión no tiene demasiada complicación, pero la segunda hay que desarrollarla. 

Empecemos con el caso $N = 2$. Se tiene entonces que 

$$
w_1  = A_1\cos(k(\phi - \alpha_1)) \quad
w_2 = A_2\cos(k(\phi - \alpha_2)) 
$$

La suma de las ondas será una tecer onda con igual período pero distinta amplitud y fase. [Se puede demostrar](http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf) que la amplitud $A_3$ de dicha suma es 

$$A(w_1 + w_2) = A_3 = \sqrt{A_1^2 + A_2^2 + 2A_1A_2\cos(\alpha_1 - \alpha_2)}$$

En el caso de ondas perfectamente estacionarias se tiene que $\alpha_1 = \alpha_2 = \alpha_i = \alpha_0$ (o equivalentemente, $\alpha_i \ne \alpha_0 \rightarrow  A_i = 0$) de manera que $A_3 = A_1 + A_2$ y generalizando a la suma en $N$, se llega a que

$$
\begin{aligned}
A \left ( \frac{1}{N}\sum_{i=1}^{N}w_i\right)  &=  \frac{1}{N}\sum_{i=1}^{N}A(w_i) \\
A(\overline{w_i})& = \overline{A(w_i)} 
\end{aligned}
$$

Es decir, para ondas perfectamente estacionarias, $AM/MA = 1$. 

Para ondas con fase completamente aleatoria... ???

ok, acá se me acaba la matemática pura y viene la parte empírica. Para distintos valores de $N$, calculo la amplitud de la suma de $N$ ondas con amplitud constante (2, en este caso) y fase aleatoria ($\alpha \sim U(-\pi, \pi)$). Repito eso 1000 veces y calculo el promedio. Esto me da una estimación de la esperanza matemática de $A(\overline{w_i})$ para distintos tamaños muestrales.

```{r sim-fun, include=FALSE}
sumwaves <- function(amplitudes, phases) {
   amplitude_sum <- amplitudes[1]
   phase_sum <- phases[1]
   for (i in seq_along(amplitudes)[-1]) {
      phase_dif <- phase_sum - phases[i]
      amplitude_sum <- sqrt(amplitude_sum^2 + amplitudes[i]^2 + 
                               2*amplitude_sum*amplitudes[i]*cos(phase_dif))
      phase_sum <- suppressWarnings(asin(amplitudes[i]*sin(phase_dif)/amplitude_sum))
      if (!is.finite(phase_sum)) phase_sum <- 0
   }
   amplitude_sum
}

amplsum <- function(N = 2, A = 2) {
   amplitudes <- rep(A, N)
   phases <-  runif(N, -pi, pi)
   sumwaves(amplitudes, phases)
}
```


```{r calc-sim, include=FALSE}
library(data.table)
library(ggplot2)

B <- 1000
trials <- data.table(t = seq(2, 1000, by = 10))
set.seed(42)
trials[, ampl := mean(sapply(1:B, function(x) amplsum(t))), by = t]
               
trials[, mean := ampl/t] 
trials[, mean(mean*sqrt(t), na.rm = TRUE)] -> k
```

```{r sim, echo=FALSE, fig.cap="Amplitud del promedio de N ondas con amplitud = 2. La línea roja es la línea $y = \\sqrt{\\frac{\\pi}{x}}$.", out.extra = "", fig.height=3}
ggplot(trials, aes(t, mean)) +
   geom_line(size = 1.3) +
   stat_function(fun = function(x) 1/2*2*sqrt(pi/x), color = "red") +
   scale_y_continuous("Amplitud") +
   scale_x_continuous("N") 
```

Se puede ver en la Figura \ref{fig:sim} que $\lim_{N\rightarrow \infty} A(\overline{w_i})= 0$ y que va como $\sim N^{-1/2}$ aunque con una constante multiplicativa que en este caso es $k = `r round(k, 3)`$. La parte más empírica viene ahora, porque *jugando* con este y otros casos, se puede ver que esa contante es $k = \frac{\overline{A}}{2}\sqrt{\frac{\pi}{N}}$. De manera que, *empíricamente* se puede ver que en el caso de ondas con fase totalmente aleatorias 


$$
A(\overline{w_i}) = \overline{A(w_i)} \frac{1}{2}\sqrt{\frac{\pi}{N}}
$$

Poniendo todo en limpio, se demostró (con una mezcla de teoría y práctica), que si se define $S = \frac{A(\overline{w_i})}{\overline{A(w_i)}}$ como medida de estacionariedad, se tiene que 

$$
\frac{1}{2}\sqrt{\frac{\pi}{N}} \le S \le 1
$$

y que las igualdades izquierda y derecha valen para el caso de pura inestacionariedad y pura estacionariedad respectivamente. 



# Otras posibles medidas de estacionariedad 

## Desvió estándar de la fase

Una forma intuitiva de media la estacionariedad es simplemente ver la variabilidad en la fase. Una onda perfectamente estacionaria debería tener nula variabilidad en la fase mientras que una onda totalmente "antiestacionaria" tendría variabilidad ¿infinita?

El problema de esta medida es que no tiene en cuenta lo que sucede con la fase. Puede darse el caso de fase con variabilidad infinita pero donde la amplitud es función de la fase. Es decir, que la onda tenga amplitud máxima para una fase determinada. En ese caso, es válido hablar de que la onda tiene un nivel de estacionariedad y se vería así en los promedios. 

## Correlación entre fase y amplitud

Siguiendo el razonamiento anterior, es posible pensar en utilizar la correlación entre la amplitud y la desviación absoluta entre la fase y la fase media. Una correlación negativa sería entonces indicio de estacionariedad ya que indicaría que si la onda está lejos de la fase media, la amplitud debería ser pequeña. 

Es una medida que funciona relativamente bien (basado en probarlo en datos reales) pero es bastante más ruidosa. Además, al usar la correlación se elimina el efecto de la variabilidad en la fase; dos grupos de ondas pueden tener la misma correlación entre fase y amplitud pero si uno tiene mayor variabilidad en la fase, implicaría menor estacionariedad. 

Por otro lado, es difícil interpretar correlaciones positivas. 

## Covarianza entre fase y amplitud

Una alternativa a la medida anterior. En principio tiene el mismo problema que la correlación, pero además se mezcla la magnitud de la variabildiad de la amplitud. Regiones con pequeña varianza en la amplitud de las ondas (como en los trópicos) van a tener valores pequeños de covarianza aún cuando las ondas sean perfectamente estacionarias. 


## Desvío estándar de la fase pesado por la amplitud

La primer alternativa tiene el problema que no tiene en cuenta lo que sucede con la amplitud en relación a la fase. Una posible forma de corregirlo sería la de pesar la fase por la amplitud. De esta manera, una onda con fase muy distinta a la media pero con poca amplitud, contribuye poco a la variabilidad. 


```{r read-data}
meanfun <- function(x, group, fun, ...) {
   dt <- data.table(x, group)
   dt[, group2 := seq_len(.N), by = group]
   
   mf <- dt[, .(f = fun(x, ...)), by = group][, .(mf = mean(f, na.rm = TRUE))]$mf
   fm <- dt[, .(m = mean(x, na.rm = TRUE)), by = group2][, .(fm = fun(m, ...))]$fm
   
   return(list(mean.fun = mf, fun.mean = fm))
}


r_z <- function(x, n = 108) {
   tanh(mean(atanh(x)))
}

ncep <- ReadNetCDF("DATA/NCEP Reanalysis/hgt.mon.mean.nc", c(gh = "hgt"), 
                   subset = list(lat = -90:0, time= lubridate::as_datetime(c("1979-12-01",
                                                                           "2015-12-01"))))
setnames(ncep, "level", "lev")

ncep[, FitWave(gh, 3), by = .(lat, lev, time)] %>% 
   .[, phase := circular(phase*3, modulo = "2pi")] %>% 
   .[, amplitude := amplitude/sum(amplitude), by = .(lat, lev, season(time))] %>% 
   .[, {
          wm <- mean.circular(phase)
          sqrt(sum(amplitude * (phase - wm)^2))
   }  , by = .(lat, lev, season(time))] -> p

ncep.qs <- ncep[ , meanfun(gh, time, function(x) FitWave(x, 3)$amplitude),
                by = .(lat, lev, season(time))]

# cormap <- copy(ncep)[, qs3 := FilterWave(gh, 3), by = .(lat, lev, time)] %>% 
#    .[, qs3.mean := mean(qs3), by = .(lon, lat, lev, season(time))] %>% 
#    .[, .(cor = cor(qs3, qs3.mean)), by = .(lat, lev, season(time))]
ncep[, qs3 := FilterWave(gh, 3), by = .(lat, lev, time)] %>%
   .[, qs3.mean := mean(qs3), by = .(lon, lat, lev, season(time))]

cors <- ncep[, .(cor = cor(qs3, qs3.mean), n = .N), by = .(lat, lev, time)]

cormap <- cors[, 
               .(r = mean(cor),
                 r_z = r_z(cor, n)), 
               by = .(lat, lev, season(time))] 

copy(cors)[, mean.cor := RcppRoll::roll_mean(cor, 12, fill = NA), 
           by = .(lat, lev)] %>% 
   .[lat %between% c(-65, -40) & lev %between% c(100, 700), 
     .(mean.cor = mean(cor)), by = .(time)] -> ts
remove(ncep)
```



```{r scatter, fig.cap = "Relación entre SD y AM/MA", fig.height=3}
p[ncep.qs, on = c("lat", "lev", "season")] %>% 
   ggplot(aes(fun.mean/mean.fun, V1)) +
   geom_point(alpha = 0.4, size = 0.5) +
   scale_x_continuous("AM/MA") +
   scale_y_continuous("SD")  
```

```{r plots, fig.cap = "Desvío estándar pesado de la fase en color, amplitud de la media sobre media de la amplitud en contornos"}
binwidth.stat <- 0.15
binwidth.ampl <- 10
ggplot(ncep.qs, aes(lat, lev)) +
   geom_contour_fill(aes(z = V1), data = p[lat < 0], binwidth = 0.4) + 
   geom_contour_tanaka(aes(z =fun.mean/mean.fun), breaks = MakeBreaks(binwidth.stat),
                       na.rm = TRUE) +
   scale_fill_viridis_c(guide = guide_colorstrip_bottom(),
                        option = "D", direction = -1,
                        breaks = MakeBreaks(1)) +
   scale_y_level() +
   scale_x_latitude(name = "latitude", trans = "reverse", ticks = 15) +
   # coord_latlev() +
   facet_wrap( ~ season) 
```

Por lo que estuve viendo, esta métrica sirve bastante bien aunque tiene un problema en que no es una medida necesariamente lineal, como se muestra en la Figura 2. Además, si bien una onda perfectamente estacionaria tendría un sd nulo, una no estacionaria alcanzaría un máximo que no conozco. 

Tendría que ver qué propiedades tiene. 


## Correlación media entre la onda 3 mensual y la onda 3 media

Otra medida posible es la correlación media entre la onda 3 de cada mes y la onda 3 media. Un pequeño detalle es que algunos autores recomiendan primero transformar los valores usando la transformada de Fischer, promediar esos valores y luego hacer la transformación inversa.
Para evaluar ambos, llamo $r$ a la correalción media y $r_z$ a la inversa de la correlación media transformada. 

```{r cor-am, fig.cap = "Relación entre la correlación media sin transformar y las otras dos medidas", fig.height=4}
ncep.qs[cormap, on = c("lat", "lev", "season")] %>% 
   .[, am.ma := fun.mean/mean.fun] %>% 
   .[, .(lat, lev, season, r, r_z, am.ma)] %>% 
   melt(id.vars = c("lat", "lev", "season", "am.ma")) %>% 
   ggplot(aes(am.ma, value, color = variable)) +
   geom_smooth(size = 0.5) +
   geom_point(alpha = 0.2, size = 0.1) +
   # geom_hex(color = NA) +
   stat_subset(aes(subset = value < 0), color = "black", size = 0.5) +
   geom_abline(linetype = 3) +
   scale_color_brewer(palette = "Set1") +
   scale_y_continuous("Correlación") +
   scale_x_continuous("AM/MA") +
   coord_equal() 
```

Como se ve en la Figura 4, donde se muestran las dos medidas de correlación en función de AM/MA, $r$ tiene una relación más lineal con AM/MA y además es más similar (más cercana a la línea punteada) que $r_z$. En comparación a AM/MA, $r_z$ tiende a sobreestimar la estacionariedad mientras que $r$ tiende a subestimarla, aunque en menor medida. 

En principio hablar de sub o sobreestimar no es del todo correcto, ya que, en principio, también podría decirse que tanto $r$ como AM/MA sobreestiman la estacionariedad en comparación a $r_z$. Sin emabrgo, en la literatura dice que $r$ tiende a subestimar la correlación poblacional mientras que $r_z$ tiende a sobreestimarla, algo que es consistente con lo que se observa en la Figura 4. Sin embargo, la literatura dice que el sesgo de $r_z$ es *menor* que el sesgo de $r$ y esto no se cumple en este caso *asumiento que AM/MA representa la correlación verdadera*.

Un problema es que, a diferencia de AM/MA que es no negativa por construcción, tanto $r$ como $r_z$ puede tomar valores negativos (marcados con puntos negros en la Figura 4) que no son fáciles de interpretar. La interpretación más consistente, en mi opinión, es que se trata de correlaciones poblacionales nulas o muy pequeñas que son negativas por variabilidad en el sampleo. 

Observando los campos (Figura 5), es notable que $r_z$ es más *ruidoso* que $r_z$, especialmente en reciones con baja estacionariedad. Supuestamente esto también está reflejado en la literatura, que dice que $r_z$ tiene mayor varianza. 

```{r cormap, fig.cap = "$r$ en color, $r_z$ en contornos"}
ggplot(cormap, aes(lat, lev)) +
   geom_contour_fill(aes(z = r), breaks = MakeBreaks(binwidth.stat)) +
   geom_contour_tanaka(aes(z = r_z), breaks = MakeBreaks(binwidth.stat), linetype = 1) +
   scale_fill_viridis_c(guide = guide_colorstrip_bottom(),
                        option = "D",
                        breaks = MakeBreaks(binwidth.stat)) +
   scale_y_level() +
   scale_x_latitude(trans = "reverse") +
   facet_wrap(~season)
```




