---
title: "estacionariedad"
author: "Elio"
date: "July 20, 2018"
output: pdf_document
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE,
                      warning = FALSE, message = FALSE,
                      cache.path = "cache/estacionariedad_proof/",
                      fig.path = "fig/estacionariedad_proof/")

library(metR)
library(data.table)
library(ggplot2)
library(metR)
library(magrittr)
library(circular)
library(RcppRoll)

source("scripts/helperfun.R")

theme_elio <- theme_minimal(base_size = 11) +
   theme(
      # text = element_text(family = font_rc),
      legend.position = "bottom", legend.box = "vertical",
      panel.spacing.y = unit(5, "mm"),
      panel.spacing.x = unit(5, "mm"),
      legend.spacing = unit(2, "mm"),
      plot.margin = grid::unit(rep(3, 4), "mm"),
      legend.title = element_blank(),
      legend.box.spacing = unit(3, "mm"),
      legend.margin = margin(t = -5),
      panel.grid = element_line(color = "gray50", size = 0.2, linetype = 3),
      panel.ontop = TRUE)
theme_set(theme_elio)
guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
   guide_colorstrip(title.position = "top", title.hjust = 0.5,
                    barheight = height,
                    barwidth = width, ...)
}

```

# Demostración matemática de las propiedades de la estacionariedad

La idea es tener un fundamento matemático robusto para la medida de estacionariedad que estoy usando. La medida es la razón entre el promedio de la amplitud de las ondas 3 mensuales (AM) y la amplitud de la onda 3 del promedio las ondas mensuales (MA). Es decir, si la amplitud de una onda $w_i$ es $A(w_i)$, se tiene que 

$$
\begin{aligned}
\overline{A(w_i)} &= \frac{1}{N}\sum_{i=1}^{N}A(w_i) \\
A(\overline{w_i}) &= A \left ( \frac{1}{N}\sum_{i=1}^{N}w_i\right) 
\end{aligned}
$$

La primera expresión no tiene demasiada complicación, pero la segunda hay que desarrollarla. 

Empecemos con el caso $N = 2$. Se tiene entonces que 

$$
w_1  = A_1\cos(k(\phi - \alpha_1)) \quad
w_2 = A_2\cos(k(\phi - \alpha_2)) 
$$

La suma de las ondas será una tecer onda con igual período pero distinta amplitud y fase. [Se puede demostrar](http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf) que la amplitud $A_3$ de dicha suma es 

$$A(w_1 + w_2) = A_3 = \sqrt{A_1^2 + A_2^2 + 2A_1A_2\cos(\alpha_1 - \alpha_2)}$$

En el caso de ondas perfectamente estacionarias se tiene que $\alpha_1 = \alpha_2 = \alpha_i = \alpha_0$ (o equivalentemente, $\alpha_i \ne \alpha_0 \rightarrow  A_i = 0$) de manera que $A_3 = A_1 + A_2$ y generalizando a la suma en $N$, se llega a que

$$
\begin{aligned}
A \left ( \frac{1}{N}\sum_{i=1}^{N}w_i\right)  &=  \frac{1}{N}\sum_{i=1}^{N}A(w_i) \\
A(\overline{w_i})& = \overline{A(w_i)} 
\end{aligned}
$$

Es decir, para ondas perfectamente estacionarias, $AM/MA = 1$. 

Para ondas con fase completamente aleatoria... ???

ok, acá se me acaba la matemática pura y viene la parte empírica. Para distintos valores de $N$, calculo la amplitud de la suma de $N$ ondas con amplitud constante (2, en este caso) y fase aleatoria ($\alpha \sim U(-\pi, \pi)$). Repito eso 1000 veces y calculo el promedio. Esto me da una estimación de la esperanza matemática de $A(\overline{w_i})$ para distintos tamaños muestrales.

```{r sim-fun, include=FALSE}
sumwaves <- function(amplitudes, phases) {
   amplitude_sum <- amplitudes[1]
   phase_sum <- phases[1]
   for (i in seq_along(amplitudes)[-1]) {
      phase_dif <- phase_sum - phases[i]
      amplitude_sum <- sqrt(amplitude_sum^2 + amplitudes[i]^2 + 
                               2*amplitude_sum*amplitudes[i]*cos(phase_dif))
      phase_sum <- suppressWarnings(asin(amplitudes[i]*sin(phase_dif)/amplitude_sum))
      if (!is.finite(phase_sum)) phase_sum <- 0
   }
   amplitude_sum
}

amplsum <- function(N = 2, A = 2) {
   amplitudes <- rep(A, N)
   phases <-  runif(N, -pi, pi)
   sumwaves(amplitudes, phases)
}
```


```{r calc-sim, include=FALSE}
library(data.table)
library(ggplot2)

B <- 1000
trials <- data.table(t = seq(2, 1000, by = 10))
set.seed(42)
trials[, ampl := mean(sapply(1:B, function(x) amplsum(t))), by = t]
               
trials[, mean := ampl/t] 
trials[, mean(mean*sqrt(t), na.rm = TRUE)] -> k
```

```{r sim, echo=FALSE, fig.cap="Amplitud del promedio de N ondas con amplitud = 2. La línea roja es la línea $y = \\sqrt{\\frac{\\pi}{x}}$.", out.extra = "", fig.height=3}
ggplot(trials, aes(t, mean)) +
   geom_line(size = 1.3) +
   stat_function(fun = function(x) 1/2*2*sqrt(pi/x), color = "red") +
   scale_y_continuous("Amplitud") +
   scale_x_continuous("N") 
```

Se puede ver en la Figura \ref{fig:sim} que $\lim_{N\rightarrow \infty} A(\overline{w_i})= 0$ y que va como $\sim N^{-1/2}$ aunque con una constante multiplicativa que en este caso es $k = `r round(k, 3)`$. La parte más empírica viene ahora, porque *jugando* con este y otros casos, se puede ver que esa contante es $k = \frac{\overline{A}}{2}\sqrt{\frac{\pi}{N}}$. De manera que, *empíricamente* se puede ver que en el caso de ondas con fase totalmente aleatorias 


$$
A(\overline{w_i}) = \overline{A(w_i)} \frac{1}{2}\sqrt{\frac{\pi}{N}}
$$

Poniendo todo en limpio, se demostró (con una mezcla de teoría y práctica), que si se define $S = \frac{A(\overline{w_i})}{\overline{A(w_i)}}$ como medida de estacionariedad, se tiene que 

$$
\frac{1}{2}\sqrt{\frac{\pi}{N}} \le S \le 1
$$

y que las igualdades izquierda y derecha valen para el caso de pura inestacionariedad y pura estacionariedad respectivamente. 



# Otras posibles medidas de estacionariedad 

## Desvió estándar de la fase

Una forma intuitiva de media la estacionariedad es simplemente ver la variabilidad en la fase. Una onda perfectamente estacionaria debería tener nula variabilidad en la fase mientras que una onda totalmente "antiestacionaria" tendría variabilidad ¿infinita?

El problema de esta medida es que no tiene en cuenta lo que sucede con la amplitud. Puede darse el caso de fase con variabilidad infinita pero donde la amplitud es función de la fase. Es decir, que la onda tenga amplitud máxima para una fase determinada. En ese caso, es válido hablar de que la onda tiene un nivel de estacionariedad y se vería así en los promedios. 

## Correlación entre fase y amplitud

Siguiendo el razonamiento anterior, es posible pensar en utilizar la correlación entre la amplitud y la desviación absoluta entre la fase y la fase media. Una correlación negativa sería entonces indicio de estacionariedad ya que indicaría que si la onda está lejos de la fase media, la amplitud debería ser pequeña. 

Es una medida que funciona relativamente bien (basado en probarlo en datos reales) pero es bastante más ruidosa. Además, al usar la correlación se elimina el efecto de la variabilidad en la fase; dos grupos de ondas pueden tener la misma correlación entre fase y amplitud pero si uno tiene mayor variabilidad en la fase, implicaría menor estacionariedad. 

Por otro lado, es difícil interpretar correlaciones positivas. 

## Covarianza entre fase y amplitud

Una alternativa a la medida anterior. En principio tiene el mismo problema que la correlación, pero además se mezcla la magnitud de la variabildiad de la amplitud. Regiones con pequeña varianza en la amplitud de las ondas (como en los trópicos) van a tener valores pequeños de covarianza aún cuando las ondas sean perfectamente estacionarias. 


## Desvío estándar de la fase pesado por la amplitud

La primer alternativa tiene el problema que no tiene en cuenta lo que sucede con la amplitud en relación a la fase. Una posible forma de corregirlo sería la de pesar la fase por la amplitud. De esta manera, una onda con fase muy distinta a la media pero con poca amplitud, contribuye poco a la variabilidad. 

```{r read-data}
ncep <- ReadNetCDF("DATA/NCEP Reanalysis/hgt.mon.mean.nc", c(gh = "hgt"), 
                   subset = list(lat = -90:0, time= lubridate::as_datetime(c("1979-12-01",
                                                                           "2015-12-01"))))
setnames(ncep, "level", "lev")
```

```{r calc-data}
meanfun <- function(x, group, fun, ...) {
   dt <- data.table(x, group)
   dt[, group2 := seq_len(.N), by = group]
   
   mf <- dt[, .(f = fun(x, ...)), by = group][, .(mf = mean(f, na.rm = TRUE))]$mf
   fm <- dt[, .(m = mean(x, na.rm = TRUE)), by = group2][, .(fm = fun(m, ...))]$fm
   
   return(list(mean.fun = mf, fun.mean = fm))
}


r_z <- function(x, w = NULL, ...) {
   if (is.null(w)) w <- rep(1/length(x), length(x))
   tanh(weighted.mean(atanh(x), w, ...))
}

ncep[, FitWave(gh, 3), by = .(lat, lev, time)] %>% 
   .[, phase := circular(phase*3, modulo = "2pi")] %>% 
   .[, amplitude := amplitude/sum(amplitude), by = .(lat, lev, season(time))] %>% 
   .[, {
          wm <- mean.circular(phase)
          sqrt(sum(amplitude * (phase - wm)^2))
   }  , by = .(lat, lev, season(time))] -> p

ncep.qs <- ncep[ , meanfun(gh, time, function(x) FitWave(x, 3)$amplitude),
                by = .(lat, lev, season(time))]

cors <- ncep[, qs3 := FilterWave(gh, 3), by = .(lat, lev, time)] %>%
   .[, qs3.mean := mean(qs3), by = .(lon, lat, lev, month(time))] %>% 
   .[, .(cor = cor(qs3, qs3.mean), amplitude = FitWave(qs3, 3)$amplitude), 
     by = .(lat, lev, time)]

regr.month <- cors[is.finite(atanh(cor)), 
                         FitLm(atanh(cor), year = year(time), se = TRUE), 
                         by = .(lat, lev, month(time))] 

cors.season <- ncep[, qs3.mean := mean(qs3), by = .(lon, lat, lev, season(time))] %>% 
   .[, .(cor = cor(qs3, qs3.mean), amplitude = FitWave(qs3, 3)$amplitude), 
     by = .(lat, lev, time)]

cormap <- cors.season[, 
                      .(r = mean(cor), 
                        r_z = r_z(cor)), 
                      by = .(lat, lev, season(time))] 

regr.season <- cors.season[, .(r = r_z(cor)), 
                           by = .(lat, lev, year(time), season(time))] %>% 
   .[is.finite(atanh(r)), FitLm(r, year, se = TRUE), by = .(lat, lev, season)]

cor.ts <- cors[lat %between% c(-65, -40) & lev %between% c(100, 700),
               .(cor.z = mean(atanh(cor)),
                 cor.z.max = max(atanh(cor))), 
               by = .(time)] %>% 
   .[, cor.z.roll := RcppRoll::roll_mean(cor.z, 12*5, fill = NA)]
```



```{r scatter, fig.cap = "Relación entre SD y AM/MA", fig.height=3}
p[ncep.qs, on = c("lat", "lev", "season")] %>% 
   ggplot(aes(fun.mean/mean.fun, V1)) +
   geom_point(alpha = 0.4, size = 0.5) +
   scale_x_continuous("AM/MA") +
   scale_y_continuous("SD")  
```

```{r plots, fig.cap = "Desvío estándar pesado de la fase en color, amplitud de la media sobre media de la amplitud en contornos"}
binwidth.stat <- 0.15
binwidth.ampl <- 10
ggplot(ncep.qs, aes(lat, lev)) +
   geom_contour_fill(aes(z = V1), data = p[lat < 0], binwidth = 0.4) + 
   geom_contour_tanaka(aes(z =fun.mean/mean.fun), breaks = MakeBreaks(binwidth.stat),
                       na.rm = TRUE) +
   scale_fill_viridis_c(guide = guide_colorstrip_bottom(),
                        option = "D", direction = -1,
                        breaks = MakeBreaks(1)) +
   scale_y_level() +
   scale_x_latitude(name = "latitude", trans = "reverse", ticks = 15) +
   # coord_latlev() +
   facet_wrap( ~ season) 
```

Por lo que estuve viendo, esta métrica sirve bastante bien aunque tiene un problema en que no es una medida necesariamente lineal, como se muestra en la Figura 2. Además, si bien una onda perfectamente estacionaria tendría un sd nulo, una no estacionaria alcanzaría un máximo que no conozco. 

Tendría que ver qué propiedades tiene. 


## Correlación media entre la onda 3 mensual y la onda 3 media

Otra medida posible es la correlación media entre la onda 3 de cada mes y la onda 3 media. Un pequeño detalle es que algunos autores recomiendan primero transformar los valores usando la transformada de Fischer, promediar esos valores y luego hacer la transformación inversa.
Para evaluar ambos, llamo $r$ a la correalción media y $r_z$ a la inversa de la correlación media transformada. 

```{r cor-am, fig.cap = "Relación entre la correlación media sin transformar y las otras dos medidas", fig.height=4}
ncep.qs[cormap, on = c("lat", "lev", "season")] %>% 
   .[, am.ma := fun.mean/mean.fun] %>% 
   .[, .(lat, lev, season, r, r_z, am.ma)] %>% 
   melt(id.vars = c("lat", "lev", "season", "am.ma")) %>% 
   ggplot(aes(am.ma, value, color = variable)) +
   geom_smooth(size = 0.5) +
   geom_point(alpha = 0.2, size = 0.1) +
   # geom_hex(color = NA) +
   stat_subset(aes(subset = value < 0), color = "black", size = 0.5) +
   geom_abline(linetype = 3) +
   scale_color_brewer(palette = "Set1") +
   scale_y_continuous("Correlación") +
   scale_x_continuous("AM/MA") +
   coord_equal() 
```

Como se ve en la Figura 4, donde se muestran las dos medidas de correlación en función de AM/MA, $r$ tiene una relación más lineal con AM/MA y además es más similar (más cercana a la línea punteada) que $r_z$. En comparación a AM/MA, $r_z$ tiende a sobreestimar la estacionariedad mientras que $r$ tiende a subestimarla, aunque en menor medida. 

En principio hablar de sub o sobreestimar no es del todo correcto, ya que, en principio, también podría decirse que tanto $r$ como AM/MA sobreestiman la estacionariedad en comparación a $r_z$. Sin emabrgo, en la literatura dice que $r$ tiende a subestimar la correlación poblacional mientras que $r_z$ tiende a sobreestimarla, algo que es consistente con lo que se observa en la Figura 4. Sin embargo, la literatura dice que el sesgo de $r_z$ es *menor* que el sesgo de $r$ y esto no se cumple en este caso *asumiento que AM/MA representa la correlación verdadera*.

Un problema es que, a diferencia de AM/MA que es no negativa por construcción, tanto $r$ como $r_z$ puede tomar valores negativos (marcados con puntos negros en la Figura 4) que no son fáciles de interpretar. La interpretación más consistente, en mi opinión, es que se trata de correlaciones poblacionales nulas o muy pequeñas que son negativas por variabilidad en el sampleo. 

Observando los campos (Figura 5), es notable que $r_z$ es más *ruidoso* que $r_z$, especialmente en regiones con baja estacionariedad. Supuestamente esto también está reflejado en la literatura, que dice que $r_z$ tiene mayor varianza. 

```{r cormap, fig.cap = "$r$ en color, $r_z$ en contornos"}
ggplot(cormap, aes(lat, lev)) +
   geom_contour_fill(aes(z = r), breaks = MakeBreaks(binwidth.stat)) +
   geom_contour_tanaka(aes(z = r_z), breaks = MakeBreaks(binwidth.stat), linetype = 1) +
   scale_fill_viridis_c(guide = guide_colorstrip_bottom(),
                        option = "D",
                        breaks = MakeBreaks(binwidth.stat)) +
   scale_y_level() +
   scale_x_latitude(trans = "reverse") +
   facet_wrap(~season)
```


Lo bueno de esta medida es que puede aplicarse a meses individuales y analizar la variabilidad temporal. Por ejemplo, la tendencia lineal (Figura 6 y Figura 7).

```{r cor-ts, fig.cap = "Mean correlation for latitude between 65°S and 40°S and level between 100hPa 700hPa.", fig.height=3}
ggplot(cor.ts, aes(time, tanh(cor.z))) + 
   geom_hline(yintercept = 0, size = 0.5) +
   geom_line(color = "gray") + 
   # geom_line(aes(y = tanh(cor.z.max)), color = "red") +
   geom_smooth(span = 0.25, se = F, color = "black") +
   geom_smooth(method = "lm") +
   scale_y_continuous("Stationarity", trans = "atanh",
                      breaks = pm(c(seq(0, 1, by = 0.2), 0.9, 0.95, 0.99, 0.99))) 
```


```{r regr-cor, fig.cap = "Linear regression estimate for stationarity (correlation per decade)."}
rect.annotation <- data.frame(latmin = -65, latmax = -40,
                              levmin = 100, levmax = 700, 
                              k = 3)
regr.season[term == "year"] %>% 
   ggplot(aes(lat, lev)) + 
   geom_contour_fill(aes(z = tanh(estimate)), breaks = AnchorBreaks(0, 0.01, 0)) +
   geom_index.region(rect.annotation) +
   # geom_contour2(aes(z = tanh(estimate))) +
   stat_subset(aes(subset = abs(estimate)/std.error > 1.96), geom = "point",
               size = 0.2) +
   scale_y_level() + 
   scale_fill_divergent(trans = "atanh", breaks = AnchorBreaks(0, 0.01, 0),
                        guide = guide_colorstrip_bottom()) + 
   scale_x_latitude(trans = "reverse") + 
   facet_wrap(~season)
```

#### Críticas ex post facto

Pensándo sobre esto, ¿tiene sentido usar la correlación como medida de estacionariedad a nivel mensual? Lo que estoy haciendo es básicamente comparando qué tan parecida es la onda mensual con la onda media de todo el período, pero no me dice si durante ese mes o los meses cercanos la onda se movió mucho o no. Aún una onda totalmente estacionaria "localmente" (en el tiempo) aparece como poco estacionaria si la onda medio de ese período está ubicada en un lugar distinto al promedio de todo el período general. 

### Correlación media pesada por la amplitud

Luego de reflexionarlo un poco más, me parece que la correlación media entre las ondas y la onda media tiene problemas conceptuales como medida de estacionariedad. Se puede demostrar matemáticamente que la correlación entre dos ondas con igual frecuencia es idéntica al coseno de la diferencia entre las fases. De ahí que esta medida tampoco esté teniendo en cuenta la relación entre amplitud y fase. Una onda de muy baja amplitud pero corrida 180° en fase con respecto a la onda media tiene la misma magnitud de correlación que una de alta amplitud y completamente en fase con la onda media y, por tanto, pesa lo mismo cuando se promedia. 

Una forma de corregir eso es hacer un promedio pesado por la amplitud de la onda. Y ahora viene el chiste: hacer eso es idéntico a calcular AM/MA (queda en deuda la demostración matemática, pero se ve "empíricamente"). 

Con esto, creo que se justifica la decisión del AM/MA de forma más sólida y que es un muy buen candidato para la estacionariedad. 



### Yapa: S a lo largo del tiempo

Concluyo que la estacionariedad no puede estar definida para un mes en particular sino que sólo se define con respecto a un intervalo de tiempo sobre el cual se hace el promedio que se correlaciona con las ondas individuales. Lo más directo es usar todo el período, pero si interesa saber el nivel de estacionariedad en una década determinada, por ejemplo, se debe usar el promedio de esa década. Más aún, la correlación de cada campo mensual debe hacerse con el promedio del período *de ese mes* para que el ciclo anual no aparezca como una no estacionariedad.

El procedimiento para calcular la estacionariedad es calcular la onda media de cada mes durnate el período, calcular la correlación[^1] de cada onda con su promedio correspondiente y finalmente hacer un promedio pesado por la amplitud de cada onda. Para obtener una serie temporal se aplica este procedimiento con una ventana de tiempo móvil (por ejemplo, de 5 años).

[^1]: Es computacionalmente más eficiente y exacto calcular el coseno de la diferencia de fase en vez de la correlación de campos. 

```{r}
sum.waves <- function(amplitudes, phases, k = 1) {
   phases <- -k[1]*phases + pi/2
   i <- 1i
   waves <- sum(amplitudes*exp(i*phases))
   amplitude <- Mod(waves)
   phase <- -(Arg(waves) - pi/2)/k[1]
   
   return(list(amplitude = amplitude,
     phase = phase,
     k = k[1]))
}

mean.waves <- function(amplitudes, phases, k = 3) {
   wave <- sum.waves(amplitudes, phases, k)
   wave$amplitude <- wave$amplitude/length(amplitudes)
   wave
}
```

```{r}
wave.stationarity <- function(waves, group = 1, method = c("AM/MA")) {
   # waves es una lista con amplitudes, phases, y kes
   # method AM/MA
   waves <- transpose(waves)
   names(waves) <- c("amplitude", "phase", "k")
   waves <- as.data.table(waves)
   
   if (length(group) == 1) group <- rep(group, nrow(waves))
   waves[, group := group]
   
   waves[, phase_of_mean := mean.waves(amplitude, phase, k[1])$phase, 
      by = group]
   
   waves[, cor := cor.waves(phase, phase_of_mean, k)]
   waves[, weighted.mean(cor, amplitude)]
}
```

Eso es lo que se muestra en la Figura 8 para 55°S y 200hPa. Es intersante que a pesar de usar definiciones ligeramente distintas y tener los cuidados mecionados en los párrafos anteriores, se consigue un patrón muy similar al de la línea suave de la Figura 6 (que se muestra en gris en la Figura 8). Una tendencia a la baja con mínimos locales en los 90, mediados de 2010 y máximo a principios de los 2000. 

```{r amma, fig.cap = "Stationarity (mean wigthed correlation) computed in a 5 year rolling window (black) and smoothed correlation (gray)."}
qswaves <- ncep[, FitWave(gh, 3), by = .(lat, time, lev)] 
qswaves[, wave := transpose(list(amplitude = amplitude, 
                                    phase = phase, 
                                    k = k))]
w <- 12*5 + 1 
m <- rep(1:12, length.out = 61)
S <- qswaves %>% 
   # .[lat %between% c(-65, 40) & lev %between% c(100, 700)] %>%
    .[lat == -55 & lev == 200] %>%
   .[, S := listapply(wave, w, wave.stationarity, group = m), 
        by = .(lat, lev)]

ggplot(S, aes(time, S)) +
   geom_smooth(aes(y = tanh(cor.z)), size = 0.5, span = 0.25, 
               se = F, color = "gray", data = cor.ts) +
   geom_line()  +
   geom_smooth(method = "lm", color = "black") +
   scale_y_continuous(trans = "atanh")
```

