---
title: "34-cEOF CMIP6"
author: "Elio Campitelli"
output: 
   bookdown::html_document2:
         base_format: tufte::tufte_html 
link-citations: yes 
---

```{r setup, include=FALSE}
# Notification
start.time <- unclass(Sys.time())
min.time <- 10
knit_doc <- knitr::knit_hooks$get("document")

options(htmltools.dir.version = FALSE)
# knitr::knit_hooks$set(document = function(x) {
#    took <- unclass(Sys.time()) - start.time
#    if (unclass(Sys.time()) - start.time >= min.time) {
#       notify("Done knitting!", 
#              paste0("Took ", round(took), " seconds"),
#              time = 5)
#    }  
#    knit_doc(x)
# })


name <- tools::file_path_sans_ext(knitr::current_input())
knitr::opts_chunk$set(
   echo = FALSE,
   fig.path = paste0("fig/", name, "/"),
   message = FALSE,
   warning = FALSE,
   cache = TRUE, 
   cache.lazy = FALSE,
   cache.extra = 42,
   cache.path = paste0("cache/", name, "/")
)
library(data.table)
library(magrittr)
library(ggplot2)
library(metR)
library(gt)
library(tagger)
library(tidyfast)
D <- `[`

factor_ReIm <- function(part) {
   factor(part, levels = c("Real", "Imaginary"), ordered = TRUE)
}

ReIm <- function(complex) {
   list(Real = Re(complex), Imaginary = Im(complex))
}

sep_ReIm <- function(data, column, format = c("longer", "wider")) {
   R <- part <- I <- NULL
   names <- c("Real", "Imaginary")
   
   
   if (missing(column)) {
      complex <- vapply(data, function(x) inherits(x, "complex"), TRUE)
      if (sum(complex) > 1) {
         stop("`column` missing and more than one complex column found")
      }
      if (sum(complex) == 0) {
         warning("`column` missing and no complex column found. Returning unchanged data")
         return(data)
      }
      
      col <- colnames(data)[complex]
   } else {
      col <- deparse(substitute(column))
   }
   
   
   data <- data.table::copy(data)[, (names) := ReIm(get(col))]
   
   
   if (format[1] == "longer") {
      data[, c(col) := NULL]
      data <- data.table::setDT(tidyr::pivot_longer(data, Real:Imaginary, names_to = "part", values_to = col))
      data[, part := factor(part, levels = names, ordered = TRUE)]
   }
   
   return(data[])
}

source("scripts/theme.R")
theme_set(theme_elio())
guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
   ggplot2::guide_colorstrip(title.position = "top", title.hjust = 0.5,
                             barheight = height,
                             barwidth = width, ...)
}

sink <- capture.output(sf::sf_use_s2(FALSE))
geom_qmap <- function(subset = identity,
                      crop = NULL,
                      color = "gray50", size = 0.3,
                      fill = NA, wrap = c(0, 360), weighting = 0.7,
                      keep = 0.015, ...) {
   lon <- lat <- group <- NULL
   data <- map_simple(wrap = wrap, keep  = keep, weighting = weighting)
   
   if (!is.null(crop)) {
      bbox <- sf::st_bbox(data)
      
      for (n in names(crop)) {
         bbox[[n]] <- crop[[n]]
      }
      
      data <- suppressWarnings(suppressMessages(sf::st_crop(data, bbox)))
   }
   
   
   subset <- purrr::as_mapper(subset)
   data <- subset(data)
   
   ggplot2::geom_sf(data = data,
                    inherit.aes = FALSE,
                    color = color,
                    size = size,
                    fill = fill,
                    ...)
   
}

map_simple <- function(wrap = c(0, 360), keep = 0.015, weighting = 0.7) {
   map <- maps::map("world", fill = TRUE,
                    col = "transparent", plot = FALSE, wrap = wrap)
   map <- sf::st_as_sf(map)
   if (keep != 1) {
      map <- rmapshaper::ms_simplify(map, keep = keep, weighting = weighting)
   }
   
   
   map
}
```



Vamos a ver qué tan bien funcionan modelos del CMIP6 para representar los EOFs complejos. 
Me interesa el 2 en particular porque es más interesante y además porque el 1 tiene mucho de la media zonal. 

Primero listemos las simulaciones que tenemos:

```{r info-simulaciones}
folder <- "/pikachu/datos3/CMIP6/historical/mon/zg/"
files <- list.files(folder)

simulaciones <- unglue::unglue_data(files, "zg_Amon_{model}_historical_i{init}p{physics}f{forcing}_{grid}_{start_date}-{end_date}.nc4") %>% 
   as.data.table() %>% 
   D(, file := files) %>% 
   D(, members := GlanceNetCDF(file.path(folder, file))$dims$ensemble$len, by = file) %>% 
   D()
```

```{r tabla-simulaciones}
knitr::kable(simulaciones[, .(model, members, init, physics, forcing)], 
             caption = "Modelos disponibles.")
```



Hay una bocha de miembros (relativamente hablando), incluyendo algunos modelos con distintas inicializaciones, parametrizaciones físicas y forzantes solares. 
En una primera aproximación, voy a simplemente analizar el primer miembro del primer caso de cada modelo. 


```{r era5}
era5 <- "/datos/reanalysis/ERA5/mon/era5.mon.mean.nc" %>% 
   ReadNetCDF(vars = c(hgt = "z"), 
              subset = list(lat = c(-90, 10), 
                            lev = list(200, 50))) %>% 
   D(season(time) == "SON") %>% 
   D(, hgt := hgt/9.8) %>% 
   D(, lev := as.numeric(lev)) %>% 
   D(, .(hgt = mean(hgt)), by = .(lon, lat, lev, time = seasonally(time))) %>% 
   D(, model := "ERA5") %>%
   D(, time := as.Date(time))
```

```{r hgt_son}
grid <- list(lon = unique(era5$lon), 
             lat = unique(era5$lat))

periodic_lon <- function(data) {
   m_lon <- min(data$lon)
   range <- c(0, 360) + m_lon
   range2 <- c(0 - m_lon, 360) 
   
   ggperiodic::periodic(data, lon = range) %>% 
      ggperiodic::wrap(lon = range2)
}

leer_son_ <- function(file, e = 1) {
   file.path(folder, file) %>% 
      ReadNetCDF(vars = c(hgt = "zg"), 
                 subset = list(time = c("1979-01-01", NA),
                               lat = c(-90, 10),
                               plev = list(200*100, 50*100), 
                               ensemble = e)) %>% 
      setnames("plev", "lev") %>% 
      D(season(time) == "SON") %>% 
      D(, time := as.Date(time)) %>% 
      D(, lev := lev/100) %>% 
      D(, .(hgt = mean(hgt), .N), by = .(lon, lat, lev, time = seasonally(time))) %>% 
      periodic_lon() %>% 
      D(, Interpolate(hgt ~ lon + lat, x.out = grid$lon, y.out = grid$lat), by = .(time, lev)) %>% 
      D(lat <= 10) %>% 
      D(, lev := as.numeric(lev))
}

leer_son <- memoise::memoise(leer_son_, cache = cachem::cache_disk("cache/34-cEOF-CMIP6/memoise"))

normalize_lon <- function(data) {
   data <- copy(data)
   na_0 <- data[lon == 0][, mean(is.na(hgt))]
   na_360 <- data[lon == 360][, mean(is.na(hgt))]
   
   # if (na_0*na_360 != 0) {
   #   browser()
   #   stop("mal!")
   # }
   
   
   data[lon == 0]$hgt <- fifelse(is.na(data[lon == 0]$hgt), 
                                 data[lon == 360]$hgt, 
                                 data[lon == 0]$hgt)
   
   data[lon == 360]$hgt <- fifelse(is.na(data[lon == 360]$hgt), 
                                   data[lon == 0]$hgt, 
                                   data[lon == 360]$hgt)
   
   
}

hgt_son <- simulaciones %>% 
   D(, .SD[1], by = model) %>% 
   D(, leer_son(file), by = .(model)) 

hgt_son <- rbind(hgt_son, era5, use.names = TRUE)
```



```{r ceof}
compute_ceof <- function(data) {
   data %>% 
      copy() %>% 
      D(, hgt_z := hgt - mean(hgt), by = .(time, lat, lev)) %>% 
      D(, hgt_z := hgt_z/sd(hgt_z), by = .(lev)) %>% 
      D(, hgt_cplx := spectral::analyticFunction(hgt_z), by = .(time, lev, lat)) %>% 
      D(, eof := hgt_cplx) %>% 
      EOF(formula = eof ~ time | lon + lat + lev, n = 1:2)
}


ceof <- hgt_son %>% 
   D(lat %between% c(-85, -20)) %>% 
   D(, .(eof = list(compute_ceof(.SD))), by = model)
```

Un primer paso es rotar el cEOF de manera que maximice la correlación (pesada por el coseno de la latitud) con el cEOF de ERA5. 

```{r ceof_rotated}
rotate <- function(z, angle = 0) {
   complex(real = cos(angle), imaginary = sin(angle)) * z
}



ref <- ceof[model == "ERA5", eof[[1]]$right] %>%
   copy() %>% 
   setnames("eof", "eof_ref")

weighted_correlation <- function(x, y, w) {
   # w <- w/sum(w)
   # sum(x*y^2)/sqrt(sum(x^2)*sum(y^2))
   
   cov.wt(cbind(x, y), wt = w, cor = TRUE)$cor[1, 2]
}

rotate_eof <- function(eof, angle) {
   eof <- copy(eof)
   eof$right[, eof := rotate(eof, angle)]
   eof$left[, eof := rotate(eof, angle)]
   eof
}

optimise_rotation <- function(eof, ref) {
   angles <- seq(-pi, pi, by = 2*pi/180)
   data <- eof$right %>% 
      D(ref, on = .NATURAL) %>% 
      D(lev == 200 & PC == "PC2")
   
   cors <- lapply(angles, function(a) {
      data %>% 
         D(, eof2 := rotate(eof, a)) %>% 
         D(, .(correlation = weighted_correlation(Re(eof2), Re(eof_ref), cos(lat*pi/180)))) %>% 
         D(, angle := a) %>% 
         D()
   }) %>% 
      rbindlist()
   
   best_cor <- cors[which.max(correlation)]
   
   eof <- rotate_eof(eof, best_cor$angle)
   list(eof = list(eof), 
        correlation = best_cor$correlation)
   
}

ceof_rotated <- ceof[, optimise_rotation(eof[[1]], ref), by = model]
```

La Tabla \@ref(tab:cor-modelos) muestra el $r^2$ del campo espacial del cEOF2 para cada modelo con ERA5. 

```{r cor-modelos}
ceof_rotated %>% 
   D(order(-correlation)) %>% 
   D(model != "ERA5") %>% 
   D(, .(model, scales::number(correlation^2, accuracy = 0.01))) %>% 
   knitr::kable(col.names = c("Model", "Correlación espacial"), 
                caption = "R^2 espacial de los campos de cEOF2 en 200 hPa de cada modelo con ERA5.")
```


```{r ceofs-modelos, fig.width=10, fig.height=6, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF2 en 200 hPa."}
models <- ceof_rotated %>% 
   D(order(-correlation)) %>%
   D(, model)

labels <- ceof_rotated %>% 
   D(order(-correlation)) %>%
   D(, setNames(paste0(model, " (", scales::number(correlation^2, 0.01), ")"),
                model))

ceof_rotated %>% 
   D(, model := factor(model, levels = models)) 

hgt_son %>% 
   D(, model := factor(model, levels = models)) 

ceof_rotated %>% 
   # D(, denormalise(eof[[1]], "right"), by = model) %>% 
   D(, eof[[1]]$right, by = model) %>% 
   D(lev == 200) %>% 
   D(PC == "PC2") %>%
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = Re(eof))) +
   geom_contour2(aes(z = Im(eof), linetype = factor(-sign(..level..)))) +
   scale_linetype(guide = "none") +
   scale_fill_divergent() +
   geom_qmap(crop = c(ymax = -20)) +
   scale_x_longitude() +
   scale_y_latitude() +
   facet_wrap(model ~ ., labeller = labeller(model = labels))
```

La Figura \@ref(fig:ceofs-modelos) muestra los campos espaciales de los cEOFs para cada modelo, incluyendo ERA5. 

Otra cosa para calcular es el campo de regresión asociado a cada cEOF. 
Éstos se muestran en la Figura \@ref(fig:ceofs-regr). 


```{r cor_regr}
regr <- ceof_rotated %>% 
   D(, denormalise(eof[[1]], "left"), by = model) %>% 
   sep_ReIm(format = "wide") %>% 
   D(PC == "PC2") %>% 
   D(hgt_son[lev == 200], on = c("model", "time")) %>% 
   D(, FitLm(hgt, Real, Imaginary), by = .(PC, model, lon, lat, lev)) %>% 
   D(term != "(Intercept)") 


cor_regr <- regr[model == "ERA5"] %>% 
   setnames("estimate", "estimate_ref") %>% 
   D(, model := NULL) %>% 
   D(regr[model != "ERA5"], on = .NATURAL) %>% 
   na.omit() %>% 
   D(, .(correlation_regression = weighted_correlation(estimate, estimate_ref, cos(lat*pi/180))), 
     by = .(term, model))
```

```{r ceofs-regr, fig.width=7, fig.height=11, fig.cap = "Campos de regresión de altura geopotencial en 200hPa de los cEOF2."}
regr %>% 
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = estimate)) +
   geom_qmap(crop = c(ymax = 0)) + 
   scale_fill_divergent() +
   scale_x_longitude() +
   scale_y_latitude() +
   facet_grid(model ~ term)
```

La Figura \@ref(fig:cor-relation) resume la relación entre la correlación en los campos de cEOF (eje horizontal) y en los campos de regresión (eje vertical).


```{r cor-relation, fig.cap = "Correlación con ERA5 de los campos espaciales de cEOF2 en 200 hPa en el eje horizontal y correlación con ERA5 de los capmos de regresión."}
cor_regr[ceof_rotated, on = "model"] %>% 
   D(model != "ERA5") %>% 
   ggplot(aes(correlation^2, correlation_regression^2)) +
   geom_point() +
   geom_abline(color = "#667885", size = 0.3) +
   ggrepel::geom_text_repel(aes(label = model)) +
   facet_wrap(~term) +
   coord_equal() +
   scale_x_continuous(limits = c(0, 1)) +
   scale_y_continuous(limits = c(0, 1)) +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE)
```




Todo esto es para un único miembro de cada modelo, pero es importante ver si depende del miembro. 

```{r process_ensemble}
process_member_ <- function(file, e) {
   data <- leer_son(file, e)
   ceof <- compute_ceof(data[lat %between% c(-85, -20)])
   ceof <- optimise_rotation(ceof, ref)
   
   r <- denormalise(ceof$eof[[1]], "left") %>% 
      sep_ReIm(format = "wide") %>% 
      D(PC == "PC2") %>% 
      D(data[lev == 200], on = c("time")) %>% 
      D(lev == 200) %>% 
      D(, FitLm(hgt, Real, Imaginary), by = .(PC, lon, lat, lev)) %>% 
      D(term != "(Intercept)") 
   
   
   cor_regr <- regr[model == "ERA5"] %>% 
      setnames("estimate", "estimate_ref") %>% 
      D(, model := NULL) %>% 
      D(r, on = .NATURAL) %>% 
      D(lev == 200) %>% 
      na.omit() %>% 
      D(, .(correlation_regression = weighted_correlation(estimate, estimate_ref,
                                                          cos(lat*pi/180))), 
        by = .(term))
   
   
   list(eof = ceof$eof,
        regression_fields = list(r),
        correlations = list(cor_regr[, correlation := ceof$correlation][]))
}

process_member <- memoise::memoise(process_member_, 
                                   cache = cachem::cache_disk("cache/34-cEOF-CMIP6/memoise"))

process_ensemble <- function(file) {
   members <- GlanceNetCDF(file.path(folder, file))$dims$ensemble$vals
   # N <- min(10, length(members))
   # members <- members[seq_len(N)]
   
   message("Reading ", file)
   # pb <- txtProgressBar(min = 1, max = length(members), style = 3)
   r <- lapply(members, function(e) {
      # setTxtProgressBar(pb, e)
      message("Miembro ", e, " (", e/length(members), ")")
      process_member(file, e)
   }) %>% 
      rbindlist(idcol = "member")
   # close(pb)
   r
}
```

```{r cors}
cors <- simulaciones %>% 
   D(, .SD[1], by = model) %>% 
   D(,  process_ensemble(file), by = .(model, init, physics, forcing))
```

La Figura \@ref(fig:cor-relation-all) muestra lo mismo que la figura anterior, pero agregando todos los miembros de cada modelo (pero sólo para una "corrida"; es decir, mismas condiciones iniciales, misma física, mismo forzante). 

```{r cor-relation-all, fig.cap = "Igual que la figura anterior, pero para todos los miembros de cada modelo."}

cors %>% 
   dt_unnest(correlations) %>%
   ggplot(aes(correlation^2, correlation_regression^2)) +
   geom_point(aes(color = model), alpha = 0.5) +
   # geom_path(aes(color = model), alpha = 0.5) +
   geom_abline(color = "#667885", size = 0.3) +
   # ggrepel::geom_text_repel(aes(label = model)) +
   facet_wrap(.~term) +
   coord_equal() +
   scale_x_continuous(limits = c(0, 1)) +
   scale_y_continuous(limits = c(0, 1)) +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE)
```

Lo que se ve es que hay mush variabilidad en la representación del cEOF2 en cada miembro, aún dentro del mismo modelo!
La variación dentro de un mismo modelo es mayor que la variación entre modelos.  
Esto implica que no se pueden seleccionar "buenos" modelos fácilmente.

De todas formas, hay ciertas características de cada modelo.


```{r cor-relation-per-model, fig.cap = "Igual que la figura anterior, pero un panel para cada modelo", fig.height=18, fig.width=6}
cors %>% 
   dt_unnest(correlations) %>% 
   copy() %>% 
   D(, model := forcats::fct_reorder(model, -correlation^2, .fun = mean)) %>% 
   ggplot(aes(correlation^2, correlation_regression^2)) +
   
   geom_hline(data = ~.x[, .(r = mean(correlation_regression^2)), by = .(model, term)], 
              aes(yintercept = r), alpha = 0.5) +
   geom_vline(data = ~.x[, .(r = mean(correlation^2)), by = .(model, term)], 
              aes(xintercept = r), alpha = 0.5) +
   geom_point(alpha = 0.5) +
   # geom_path(aes(color = model), alpha = 0.5) +
   geom_abline(color = "#667885", size = 0.3) +
   # ggrepel::geom_text_repel(aes(label = model)) +
   facet_grid(model~term) +
   coord_equal() +
   scale_x_continuous(limits = c(0, 1)) +
   scale_y_continuous(limits = c(0, 1)) + 
   scale_color_discrete(guide = "none") +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE)
```

La Figura \@ref(fig:cor-relation-per-model) es igual que la anterior pero separa cada modelo en su propio panel para poder distinguir mejor el comportaniento de cada uno. 


```{r not-eval}
knitr::opts_chunk$set(echo = FALSE)
```

```{r cor-per-member}
cors %>% 
   dt_unnest(correlations) %>% 
   ggplot(aes(correlation^2, correlation_regression^2)) +
   geom_path(aes(group = member), alpha = 0.5) +
   geom_point(aes(color = term), alpha = 0.5) +
   geom_abline(color = "#667885", size = 0.3) +
   # ggrepel::geom_text_repel(aes(label = model)) +
   facet_wrap(model~.) +
   coord_equal() +
   scale_x_continuous(limits = c(0, 1)) +
   scale_y_continuous(limits = c(0, 1)) +
   # scale_color_discrete(guide = "none") +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE)
```


```{r best-worst-fields}
select <- cors %>% 
   dt_unnest(correlations) %>% 
   D(, .SD[c(which.min(correlation), 
             which.max(correlation))], by = .(model)) 

cors[select, on = c("model", "member")] %>% 
   D(order(correlation)) %>% 
   copy() %>% 
   D(, member := seq_len(.N), by = .(model)) %>% 
   D(, eof[[1]]$right, by = .(model, member, correlation)) %>% 
   D(lev == 200) %>% 
   D(PC == "PC2") %>%
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = Re(eof))) +
   geom_contour2(data = ref[lev == 200 & PC == "PC2"], aes(z = Re(eof_ref))) +
   scale_linetype(guide = "none") +
   scale_fill_divergent() +
   geom_qmap(crop = c(ymax = -20)) +
   geom_label(data = ~.x[, .SD[1], by = .(model, member)], 
              aes(label = scales::number(correlation^2, accuracy = 0.01)), x = 50, y = -30) +
   scale_x_longitude() +
   scale_y_latitude() +
   facet_grid(model ~ member)

```


```{r field-difference}
cors[select, on = c("model", "member")] %>% 
   D(order(correlation)) %>% 
   copy() %>% 
   D(, member := seq_len(.N), by = .(model)) %>% 
   D(, eof[[1]]$right, by = .(model, member, correlation)) %>% 
   D(lev == 200) %>% 
   D(PC == "PC2") %>%
   D(ref[lev == 200 & PC == "PC2"], on = .NATURAL) %>% 
   D(, d := Re(eof) - Re(eof_ref)) %>% 
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = d)) +
   scale_linetype(guide = "none") +
   scale_fill_divergent() +
   geom_qmap(crop = c(ymax = -20)) +
   geom_label(data = ~.x[, .SD[1], by = .(model, member)], 
              aes(label = scales::number(correlation^2, accuracy = 0.01)), x = 50, y = -30) +
   scale_x_longitude() +
   scale_y_latitude() +
   facet_grid(model ~ member)

```

