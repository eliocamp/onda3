---
title: "34-cEOF CMIP6"
author: "Elio Campitelli"
output: 
   bookdown::html_document2:
         base_format: tufte::tufte_html 
link-citations: yes 
---

```{r setup, include=FALSE}
# Notification
start.time <- unclass(Sys.time())
min.time <- 10
knit_doc <- knitr::knit_hooks$get("document")

options(htmltools.dir.version = FALSE)
# knitr::knit_hooks$set(document = function(x) {
#    took <- unclass(Sys.time()) - start.time
#    if (unclass(Sys.time()) - start.time >= min.time) {
#       notify("Done knitting!", 
#              paste0("Took ", round(took), " seconds"),
#              time = 5)
#    }  
#    knit_doc(x)
# })


name <- tools::file_path_sans_ext(knitr::current_input())
knitr::opts_chunk$set(
   echo = FALSE,
   fig.path = paste0("fig/", name, "/"),
   message = FALSE,
   warning = FALSE,
   cache = TRUE, 
   cache.lazy = FALSE,
   cache.extra = 42,
   cache.path = paste0("cache/", name, "/")
)
library(data.table)
library(magrittr)
library(ggplot2)
library(metR)
library(gt)
library(tagger)
library(tidyfast)
D <- `[`

factor_ReIm <- function(part) {
   factor(part, levels = c("Real", "Imaginary"), ordered = TRUE)
}

ReIm <- function(complex) {
   list(Real = Re(complex), Imaginary = Im(complex))
}

sep_ReIm <- function(data, column, format = c("longer", "wider")) {
   R <- part <- I <- NULL
   names <- c("Real", "Imaginary")
   
   
   if (missing(column)) {
      complex <- vapply(data, function(x) inherits(x, "complex"), TRUE)
      if (sum(complex) > 1) {
         stop("`column` missing and more than one complex column found")
      }
      if (sum(complex) == 0) {
         warning("`column` missing and no complex column found. Returning unchanged data")
         return(data)
      }
      
      col <- colnames(data)[complex]
   } else {
      col <- deparse(substitute(column))
   }
   
   
   data <- data.table::copy(data)[, (names) := ReIm(get(col))]
   
   
   if (format[1] == "longer") {
      data[, c(col) := NULL]
      data <- data.table::setDT(tidyr::pivot_longer(data, Real:Imaginary, names_to = "part", values_to = col))
      data[, part := factor(part, levels = names, ordered = TRUE)]
   }
   
   return(data[])
}

source("scripts/theme.R")
theme_set(theme_elio())
guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
   ggplot2::guide_colorstrip(title.position = "top", title.hjust = 0.5,
                             barheight = height,
                             barwidth = width, ...)
}

sink <- capture.output(sf::sf_use_s2(FALSE))
geom_qmap <- function(subset = identity,
                      crop = NULL,
                      color = "gray50", size = 0.3,
                      fill = NA, wrap = c(0, 360), weighting = 0.7,
                      keep = 0.015, ...) {
   lon <- lat <- group <- NULL
   data <- map_simple(wrap = wrap, keep  = keep, weighting = weighting)
   
   if (!is.null(crop)) {
      bbox <- sf::st_bbox(data)
      
      for (n in names(crop)) {
         bbox[[n]] <- crop[[n]]
      }
      
      data <- suppressWarnings(suppressMessages(sf::st_crop(data, bbox)))
   }
   
   
   subset <- purrr::as_mapper(subset)
   data <- subset(data)
   
   ggplot2::geom_sf(data = data,
                    inherit.aes = FALSE,
                    color = color,
                    size = size,
                    fill = fill,
                    ...)
   
}

map_simple <- function(wrap = c(0, 360), keep = 0.015, weighting = 0.7) {
   map <- maps::map("world", fill = TRUE,
                    col = "transparent", plot = FALSE, wrap = wrap)
   map <- sf::st_as_sf(map)
   if (keep != 1) {
      map <- rmapshaper::ms_simplify(map, keep = keep, weighting = weighting)
   }
   
   
   map
}

coord_polar <- function(ymax = -20, ...) {
   
   x <- c(seq(0, 360, length.out = 40), 
          seq(360, 0, length.out = 40), 
          0)
   y <- c(rep(ymax, length.out = 40), 
          rep(60, length.out = 40), 
          ymax)
   
   cbind(x, y) %>% 
      list() %>% 
      sf::st_polygon() %>% 
      sf::st_sfc(crs = "+proj=latlong") -> white
   
   list(
      geom_sf(data = white, inherit.aes = FALSE, 
              fill = "white", 
              colour = "white", size = 2),
      coord_sf(ylim = c(-90, ymax), 
               lims_method = "box",
               crs = "+proj=laea +lat_0=-90",
               default_crs = "+proj=longlat",
               label_axes =  "----", ...)
   )
}

n_eof <- 2
```


Vamos a ver qué tan bien funcionan modelos del CMIP6 para representar los EOFs complejos. 
Me interesa el 2 en particular porque es más interesante y además porque el 1 tiene mucho de la media zonal. 

Primero listemos las simulaciones que tenemos:

```{r info-simulaciones}
folder <- "/pikachu/datos3/CMIP6/historical/mon/zg/"
files <- list.files(folder)

simulaciones <- unglue::unglue_data(files, "zg_Amon_{model}_historical_i{init}p{physics}f{forcing}_{grid}_{start_date}-{end_date}.nc4") %>% 
   as.data.table() %>% 
   D(, file := files) %>% 
   D(, members := GlanceNetCDF(file.path(folder, file))$dims$ensemble$len, by = file) %>% 
   D()
```

```{r tabla-simulaciones}
knitr::kable(simulaciones[, .(model, members, init, physics, forcing)], 
             caption = "Modelos disponibles.")
```



Hay una bocha de miembros (relativamente hablando), incluyendo algunos modelos con distintas inicializaciones, parametrizaciones físicas y forzantes solares. 
En una primera aproximación, voy a simplemente analizar el primer miembro del primer caso de cada modelo. 


```{r era5}
era5 <- "/datos/reanalysis/ERA5/mon/era5.mon.mean.nc" %>% 
   ReadNetCDF(vars = c(hgt = "z"), 
              subset = list(lat = c(-90, 10), 
                            lev = list(200, 50))) %>% 
   D(season(time) == "SON") %>% 
   D(, hgt := hgt/9.8) %>% 
   D(, lev := as.numeric(lev)) %>% 
   D(, .(hgt = mean(hgt)), by = .(lon, lat, lev, time = seasonally(time))) %>% 
   D(, model := "ERA5") %>%
   D(, time := as.Date(time))
```

```{r hgt_son}
grid <- list(lon = unique(era5$lon), 
             lat = unique(era5$lat))

periodic_lon <- function(data) {
   m_lon <- min(data$lon)
   range <- c(0, 360) + m_lon
   range2 <- c(0 - m_lon, 360) 
   
   ggperiodic::periodic(data, lon = range) %>% 
      ggperiodic::wrap(lon = range2)
}

leer_son_ <- function(file, e = 1) {
   file.path(folder, file) %>% 
      ReadNetCDF(vars = c(hgt = "zg"), 
                 subset = list(time = c("1979-01-01", NA),
                               lat = c(-90, 10),
                               plev = list(200*100, 50*100), 
                               ensemble = e)) %>% 
      setnames("plev", "lev") %>% 
      D(season(time) == "SON") %>% 
      D(, time := as.Date(time)) %>% 
      D(, lev := lev/100) %>% 
      D(, .(hgt = mean(hgt), .N), by = .(lon, lat, lev, time = seasonally(time))) %>% 
      periodic_lon() %>% 
      D(, Interpolate(hgt ~ lon + lat, x.out = grid$lon, y.out = grid$lat), by = .(time, lev)) %>% 
      D(lat <= 10) %>% 
      D(, lev := as.numeric(lev))
}

leer_son <- memoise::memoise(leer_son_, cache = cachem::cache_disk("cache/34-cEOF-CMIP6/memoise"))

normalize_lon <- function(data) {
   data <- copy(data)
   na_0 <- data[lon == 0][, mean(is.na(hgt))]
   na_360 <- data[lon == 360][, mean(is.na(hgt))]
   
   # if (na_0*na_360 != 0) {
   #   browser()
   #   stop("mal!")
   # }
   
   
   data[lon == 0]$hgt <- fifelse(is.na(data[lon == 0]$hgt), 
                                 data[lon == 360]$hgt, 
                                 data[lon == 0]$hgt)
   
   data[lon == 360]$hgt <- fifelse(is.na(data[lon == 360]$hgt), 
                                   data[lon == 0]$hgt, 
                                   data[lon == 360]$hgt)
   
   
}

hgt_son <- simulaciones %>% 
   D(, .SD[1], by = model) %>% 
   D(, leer_son(file), by = .(model)) 

hgt_son <- rbind(hgt_son, era5, use.names = TRUE)
```



```{r ceof}
compute_ceof <- function(data) {
   data %>% 
      copy() %>% 
      D(, hgt_z := hgt - mean(hgt), by = .(time, lat, lev)) %>% 
      D(, hgt_z := hgt_z/sd(hgt_z), by = .(lev)) %>% 
      D(, hgt_cplx := spectral::analyticFunction(hgt_z), by = .(time, lev, lat)) %>% 
      D(, eof := hgt_cplx) %>% 
      EOF(formula = eof ~ time | lon + lat + lev, n = 1:2) %>% 
      cut(n_eof)
}

ceof <- hgt_son %>% 
   D(lat %between% c(-85, -20)) %>% 
   D(, .(eof = list(compute_ceof(.SD))), by = model)
```

Un primer paso es rotar el cEOF de manera que maximice la correlación (pesada por el coseno de la latitud) con el cEOF de ERA5. 

```{r ceof_rotated}
rotate <- function(z, angle = 0) {
   complex(real = cos(angle), imaginary = sin(angle)) * z
}

ref <- ceof[model == "ERA5", eof[[1]]$right] %>%
   copy() %>% 
   setnames("eof", "eof_ref")

weighted_correlation <- function(x, y, w) {
   # w <- w/sum(w)
   # sum(x*y^2)/sqrt(sum(x^2)*sum(y^2))
   
   cov.wt(cbind(x, y), wt = w, cor = TRUE)$cor[1, 2]
}

rotate_eof <- function(eof, angle) {
   eof <- copy(eof)
   eof$right <- eof$right[angle, on = "PC", ][, eof := rotate(eof, angle)][, angle := NULL]
   eof$left <- eof$left[angle, on = "PC", ][, eof := rotate(eof, angle)][, angle := NULL]
   eof
}

optimise_rotation <- function(eof, ref) {
   angles <- seq(-pi, pi, by = 2*pi/180)
   data <- eof$right %>% 
      D(ref, on = .NATURAL) %>% 
      D(lev == 200)
   
   cors <- lapply(angles, function(a) {
      data %>% 
         D(, eof2 := rotate(eof, a)) %>% 
         D(, .(correlation = weighted_correlation(Re(eof2), Re(eof_ref), cos(lat*pi/180))), 
           by = PC) %>% 
         D(, angle := a) %>% 
         D()
   }) %>% 
      rbindlist()
   
   best_cor <- cors[, .SD[which.max(correlation)], by = PC]
   eof <- rotate_eof(eof, best_cor[, .(PC, angle)])
   
   eof$sdev <- eof$sdev[best_cor[, .(PC, correlation, angle)], on = "PC"]
   eof
}

ceof_rotated <- ceof[, .(eof = list(optimise_rotation(eof[[1]], ref))), by = model]
```

La Tabla \@ref(tab:cor-modelos) muestra el $r^2$ del campo espacial del cEOF2 para cada modelo con ERA5. 

```{r cor-modelos}
ceof_rotated %>% 
   D(, eof[[1]]$sdev, by = model) %>% 
   # D(order(PC, -correlation)) %>% 
   D(model != "ERA5") %>% 
   D(, r2 := correlation^2) %>% 
   dcast(model ~ PC, value.var = "r2") %>% 
   D(order(-PC2)) %>% 
   knitr::kable(col.names = c("Model", "PC2"), 
                caption = "R^2 espacial de los campos de cEOF2 en 200 hPa de cada modelo con ERA5.")
```

```{r}

plot_ceof <- function(ceof, n) {
   models <- ceof %>% 
      D(, eof[[1]]$sdev, by = model) %>%
      D(order(-correlation)) 
   
   labels <- models %>%
      D(, setNames(paste0(model, " (", scales::number(correlation^2, 0.01), ")"),
                   model))
   
   ceof %>% 
      D(, denormalise(eof[[1]], "right"), by = model) %>%
      # D(, cut(eof[[1]], n)$right, by = model) %>% 
      D(, model := factor(model, levels = models$model)) %>% 
      D(lev == 200) %>% 
      ggperiodic::periodic(lon = c(0, 360)) %>% 
      ggplot(aes(lon, lat)) +
      geom_contour_fill(aes(z = Re(eof)), bins = 15) +
      geom_contour2(aes(z = Im(eof), linetype = factor(-sign(..level..))), bins = 15) +
      scale_linetype(guide = "none") +
      scale_fill_divergent() +
      geom_qmap(crop = c(ymax = -20)) +
      scale_x_longitude() +
      scale_y_latitude(limits = c(-90, NA)) +
      coord_polar() +
      facet_wrap(model ~ ., labeller = labeller(model = labels)) 
}

```



```{r ceofs-modelos, fig.width=10, fig.height=10, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF2 en 200 hPa."}
plot_ceof(ceof_rotated)
```

La Figura \@ref(fig:ceofs-modelos) muestra los campos espaciales de los cEOFs para cada modelo, incluyendo ERA5. 



Todo esto es para un único miembro de cada modelo, pero es importante ver si depende del miembro. 

```{r process_ensemble}
process_member_ <- function(file, e) {
   data <- leer_son(file, e)
   ceof <- compute_ceof(data[lat %between% c(-85, -20)])
   ceof <- optimise_rotation(ceof, ref)
   
   list(eof = list(ceof))
}

process_member <- memoise::memoise(process_member_, 
                                   cache = cachem::cache_disk("cache/34-cEOF-CMIP6/memoise"))

process_ensemble <- function(file) {
   members <- GlanceNetCDF(file.path(folder, file))$dims$ensemble$vals
   
   message("Reading ", file)

   r <- lapply(members, function(e) {

      message("Miembro ", e, " (", e/length(members), ")")
      process_member(file, e)
   }) %>% 
      rbindlist(idcol = "member")

   r
}
```

```{r cors}
cors <- simulaciones %>% 
   D(, .SD[1], by = model) %>% 
   D(,  process_ensemble(file), by = .(model, init, physics, forcing))
```

La Figura \@ref(fig:cor-relation-all) muestra lo mismo que la figura anterior, pero agregando todos los miembros de cada modelo (pero sólo para una "corrida"; es decir, mismas condiciones iniciales, misma física, mismo forzante). 

```{r cor-relation-all, fig.cap = "Distribución del r2 entre los patrones espaciales de ERA5 y cada miebro de cada modelo. La cruz marca el r2 medio de cada modelo."}
cors %>% 
   .[, eof[[1]]$sdev, by = .(model, init, physics, forcing, member)] %>%
   ggplot(aes(reorder(model, correlation^2), correlation^2)) +
   geom_violin() +
   ggforce::geom_sina(alpha = 0.5) +
   geom_point(data = ~.x[, mean(correlation^2), by = .(model)], aes(model, V1), 
              shape = "+", size = 8) +
   coord_flip() +
   scale_y_continuous(limits = c(0, 1))  +
   scale_x_discrete(NULL) +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE) 
```

Lo que se ve es que hay mush variabilidad en la representación del cEOF2 en cada miembro, aún dentro del mismo modelo!
La variación dentro de un mismo modelo es mayor que la variación entre modelos.  
Esto implica que no se pueden seleccionar "buenos" modelos fácilmente.

Para tener una idea de la variabilidad, la Figura \@ref(fig:best-worst-fields) muestra el mejor y el peor miembro de cada modelo (en base a la correlación de los campos del cEOF).

```{r best-worst-fields, fig.cap = "Mejor y peor miembro de cada modelo.", fig.height=12, fig.width=7}
select <- cors %>% 
   .[, eof[[1]]$sdev, by = .(model, init, physics, forcing, member)] %>%
   D(, .SD[c(which.min(correlation), 
             which.max(correlation))], by = .(model)) 

cors[select, on = c("model", "member")] %>% 
   D(order(correlation)) %>% 
   copy() %>% 
   D(, member := seq_len(.N), by = .(model)) %>% 
   D(, eof[[1]]$right, by = .(model, member, correlation)) %>% 
   D(lev == 200) %>% 
   D(PC == "PC2") %>%
   periodic_lon() %>% 
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = Re(eof))) +
   geom_contour2(data = ref[lev == 200 & PC == "PC2"], aes(z = Re(eof_ref)), bins = 5) +
   scale_linetype(guide = "none") +
   scale_fill_divergent() +
   geom_qmap(crop = c(ymax = -20)) +
   geom_label(data = ~.x[, .SD[1], by = .(model, member)], 
              aes(label = scales::number(correlation^2, accuracy = 0.01)), x = 90, y = -50) +
   scale_x_longitude() +
   scale_y_latitude() +
   coord_polar() + 
   facet_grid(model ~ member, labeller = labeller(member = c("1"  = "Peor", "2" = "Mejor")))
```

## Sampleo

Una posible fuente de variabilidad puede ser problemas de sampleo. 
Al computar el cEOF con una muestra finita de 40 años tanto la parte espacial como la temporal van a sufrir variaciones por sampleo. 
Esto se puede simular tomando un único miembro de un modelo y computando el cEOF usando años aleatorios.


```{r ceof-sample}
file <- simulaciones$file[1]
e = 1

shuffle_ <- function(file, e, N = 40, B = 10) {
   data <- file.path(folder, file) %>% 
      ReadNetCDF(vars = c(hgt = "zg"), 
                 subset = list(lat = c(-90, 10),
                               time = c("1979-01-01", NA),
                               plev = list(200*100, 50*100), 
                               ensemble = e)) %>% 
      setnames("plev", "lev") %>% 
      D(season(time) == "SON") %>% 
      D(, time := as.Date(time)) %>% 
      D(, lev := lev/100) %>% 
      D(, .(hgt = mean(hgt), .N), by = .(lon, lat, lev, time = seasonally(time))) %>% 
      periodic_lon() %>% 
      D(, Interpolate(hgt ~ lon + lat, x.out = grid$lon, y.out = grid$lat), by = .(time, lev)) %>% 
      D(lat <= 10) %>% 
      D(, lev := as.numeric(lev))
   
   make_correltions <- function() {
      data_subset <- data[time %in% sample(unique(time), N, replace = TRUE)]
      ceof <-compute_ceof(data_subset[lat %between% c(-85, -20)])
      ceof <- optimise_rotation(ceof, ref)
      
      list(eof = list(ceof))
   }
   
   res <- lapply(seq_len(B), function(i) make_correltions())
   
   rbindlist(res, idcol = "replication")
}
shuffle <- memoise::memoise(shuffle_, cache = cachem::cache_disk("cache/34-cEOF-CMIP6/memoise"))

sample_eof <- function(file, members) {
   lapply(members, function(e) {
      shuffle_(file, e = e, B = 30)[, member := e]
   }) %>% 
      rbindlist()
}

replications <- simulaciones %>% 
   D(, .SD[1], by = model) %>% 
   .[, sample_eof(file, 1), by = .(model)]
```


```{r}
replications_era <- lapply(1:10, function(b) {
   era_sample <- era5 %>% 
      .[time %in% sample(unique(time), 40, replace = TRUE)] 
   ceof <- compute_ceof(era_sample[lat %between% c(-85, -20)])
   ceof <- optimise_rotation(ceof, ref)
   list(eof = list(ceof))
}) %>% 
   rbindlist(idcol = "replication") %>% 
   .[, ":="(model = "ERA5", member = 1)]

```

La Figura \@ref(fig:one-member) muestra el efecto del sampleo. 
Cada punto es el r^2 espacial para el miembro 1 de cada modelo pero tomando 40 años al azar (con reemplazo). 
Aún tomando un único miembro, la correlación con ERA5 varía considerablemente si se seleccionan distintos años y el spread es comparable con el spread entre miembros. 

```{r one-member, fig.cap = "Igual que figuras anteriores pero para 20 muestras de 40 años de un único miembro."}
replications %>% 
   rbind(replications_era) %>% 
   .[, eof[[1]]$sdev, by = .(model, replication, member)] %>%
   ggplot(aes(reorder(model, correlation^2), correlation^2)) +
   geom_violin() +
   ggforce::geom_sina(alpha = 0.5) +
   geom_point(data = ~.x[, mean(correlation^2), by = model], aes(model, V1), 
              shape = "+", size = 8) +
   coord_flip() +
   scale_y_continuous(limits = c(0, 1))  +
   scale_x_discrete(NULL) +
   theme(panel.background = element_rect(fill = "#fafafa", color = NA),
         panel.ontop = FALSE) 
```

