---
title: "1 paper de la onda 3"
author: "Elio Campitelli"
date: "April 19, 2018"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
# Notification
start.time <- unclass(Sys.time())
min.time <- 10
knit_doc <- knitr::knit_hooks$get("document")
knitr::knit_hooks$set(document = function(x) {
   took <- unclass(Sys.time()) - start.time
   if (unclass(Sys.time()) - start.time >= min.time) {
      notify("Done knitting!", 
             paste0("Took ", round(took), " seconds"),
             time = 5)
   }  
   knit_doc(x)
})

knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE, cache.lazy = TRUE,
                      warning = FALSE,
                      dev = "cairo_pdf")

library(data.table)
library(ggplot2)
library(dplyr)
library(metR) 
library(circular)
library(hrbrthemes)
library(extrafont)
library(patchwork)
library(officer)

knit_error <-  knitr::knit_hooks$get("error")
knitr::knit_hooks$set(error = function(x, options) {
   notify("Error knitting!", time = 5)
   knit_error(x, options)
})


source("scripts/helperfun.R")
# Plot thingys

data.world <- BuildMap(res = 1, smooth = 1)
map.world <- geom_map2(data.world)
map.SH <- geom_map2(data.world[lat %b% c(-90, 20)], color = "gray20")


pres <- ReadNetCDF("DATA/srfp.mon.mean.nc")
pres.mean <- pres[, .(pres = median(pres)), by = lat]
pres.mean <- rbind(data.table(lat = 0.0, pres = Inf), 
                   pres.mean, 
                   data.table(lat = -90.0, pres = Inf))
surface <- geom_polygon(data = pres.mean, aes(y = pres), fill = "white", 
                        alpha = 1, color = "gray30", size = 0.5)
pres <- pres[, .(pres = mean(pres)), by = .(lon, lat)]

# From https://github.com/hrbrmstr/hrbrthemes/issues/18
d <- read.csv(extrafont:::fonttable_file(), stringsAsFactors = FALSE)
d[grepl("Light", d$FontName),]$FamilyName <- font_rc_light
write.csv(d,extrafont:::fonttable_file(), row.names = FALSE)
extrafont::loadfonts()

theme_elio <- theme_minimal(base_size = 11) +
   theme(
      text = element_text(family = font_rc),
      legend.position = "bottom", legend.box = "vertical",
      panel.spacing.y = unit(5, "mm"),
      panel.spacing.x = unit(5, "mm"),
      legend.spacing = unit(2, "mm"),
      plot.margin = grid::unit(rep(3, 4), "mm"),
      legend.title = element_blank(),
      legend.box.spacing = unit(3, "mm"),
      legend.margin = margin(t = -5),
      panel.grid = element_line(color = "gray50", size = 0.2, linetype = 3),
      panel.ontop = TRUE)
theme_set(theme_elio)
update_geom_defaults(metR:::GeomTextContour, list(family = font_rc))

update_geom_defaults("contour2", list(color = "black"))
update_stat_defaults("contour2", aes(linetype = factor(-sign(..level..))))

options(ggplot2.continuous.fill = "viridis", 
        ggplot2.continuous.color = "viridis")

coord_quickmap <- function(..., ylim = c(-90, -15)) {
   ggplot2::coord_quickmap(ylim = ylim, ...) 
} 

geom_contour_ <- function(..., gap = 0, rotate = FALSE) {
   if (gap != 0) {
      list(geom_contour2(..., gap = gap),
           geom_text_contour(..., rotate = rotate))
   } else {
      geom_contour2(...)
   }
}

# For vertical cross-sections
coord_latlev <- function(ratio = 20, ...) coord_fixed(ratio = ratio, ...)
coord_lonlev <- function(ratio = 20*4, ...) coord_fixed(ratio = ratio, ...)

lev.breaks <- c(10, 30, 100, 200, 500, 1000)

season <- function(...) {
   metR::season(..., lang = "en")
}


## Options for generating ppt output
ppt <- FALSE
pptfile <- "figuras.pptx"
ppttemplate <- "ppttemplate.pptx"
# Initial ppt
if (ppt == TRUE){
   my_pres <- read_pptx(ppttemplate)
   print(my_pres, pptfile)   
}

# Add a plot to ppt 
knit_plot <- knitr::knit_hooks$get("plot")

knitr::knit_hooks$set(plot = function(x, options) {
   if (ppt == TRUE) {
      # print(options)
      if (inherits(last_plot(), "gg")) {
         read_pptx(pptfile)  %>%
            add_slide(layout = "figure", master = "Office Theme") %>%
            ph_with_gg(last_plot(), type = "pic") %>%
            ph_with_text(options$fig.cap, type = "body") %>%
            print(pptfile)
         set_last_plot(NULL)   # remove last_plot()
      } else {
         read_pptx(pptfile ) %>%
            add_slide(layout = "figure", master = "Office Theme") %>%
            rvg::ph_with_vg(code = eval(parse(text = options$code)), 
                            type = "pic") %>%
            ph_with_text(options$fig.cap, type = "body") %>% 
            print(pptfile)
      }
   }
   knit_plot(x, options)
})

# Turn off cache for figures
knitr::opts_hooks$set(fig.cap = function(options) {
   if (ppt == TRUE) options$cache <- FALSE
   options
})

```

```{r read-ncep}
ncep.f <- memoise::memoise(function(lat = -90:40, 
                                    lon = 0:360,
                                    time = lubridate::as_datetime(c("1979-12-01", "2015-12-01")),
                                    level = 10:1000,
                                    vars = "gh"){
   subset <- list(lat = lat, lon = lon, level = level,
                  time = time)
   n <- ReadNetCDF("DATA/hgt.mon.mean.nc", vars = c(gh = "hgt"),
                   subset = subset) %>% 
      setnames(., c("level"), c("lev"))
   if ("u" %in% vars) {
      n[, u := ReadNetCDF("DATA/uwnd.mon.mean.nc", out = "vector",
                          subset = subset)[[1]]] 
   }
   if ("v" %in% vars) {
      n[, v := ReadNetCDF("DATA/vwnd.mon.mean.nc", out = "vector",
                          subset = subset)[[1]]]
   }
   n[, time := as.Date(time[1]), by = time]
   return(n)
}, cache = memoise::cache_filesystem(".rcache"))
ncep <- ncep.f(level = 200)
```

# "Tradicional" analysis.

```{r calc-fourier1}
rect.annotation <- data.frame(latmin = -65, latmax = -40,
                              levmin = 100, levmax = 700, 
                              k = 3)
ncep.qs <- ncep[, .(gh = mean(gh)), by = .(lat, lon, lev, season(time))] %>% 
   .[, FitWave(gh, k = 1:4), 
     by = .(lat, lev, season)] 
```

```{r ampl-ncep, fig.cap = "Fourier amplitude of geopotential height"}
breaks <- 2^seq(0, log2(650), by = 1)
ggplot(ncep.qs[lat <= 0], aes(lat, lev)) +
   geom_contour_fill(aes(z = amplitude),
                     breaks = breaks) +
   geom_contour_(aes(z = amplitude),
                 breaks = breaks, gap = 1, rotate = FALSE) +
   surface +
   geom_index.region(rect.annotation) +
   scale_fill_viridis_c(name = "Amplitud (escala logarítmica)", 
                        trans = "log2",
                        breaks = breaks,
                        labels = round(breaks, 1),
                        guide = guide_colorstrip_bottom(),
                        option = "D") +
   scale_y_level() +
   scale_x_latitude(name = "latitud", trans = "reverse", 
                    ticks = 15) +
   coord_latlev() +
   facet_grid(k ~ season, labeller = labeller(k = qs.lab)) 
```

```{r calc-gh3-season}
lons <- unique(ncep$lon)
qs3 <- ncep.qs[k == 3, .(lon = lons, 
                         gh = BuildField(lons*pi/180, amplitude, phase, k)), 
               by = .(lat, lev, season)]
```

```{r gh3-season, fig.cap = "Wave 3 component of the geopotential field of each season at 200hPa."}
binwidth <- 10
ggplot(qs3[lev == 200], aes(lon, lat)) +
   geom_contour_fill(aes(z = gh), breaks = AnchorBreaks(0, binwidth, 0)) +
   geom_contour_(aes(z = gh), breaks = AnchorBreaks(0, binwidth, 0), gap = 0) +
   map.SH +
   scale_s_map(ylim = c(-90, 20)) +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), 
                        name = "QS3",
                        guide = guide_colorstrip_bottom()) +
   facet_wrap(~season, ncol = 2) +
   coord_quickmap()
```

```{r qs3-season-cut, fig.cap = "Mean wave 3 component of geopotential height between 65°S and 35°S"}
cutlats <- c(-65, -35)
binwidth <- 5
ggplot(qs3[lat %between% cutlats, .(gh = mean(gh)), by = .(lon, lev, season)], 
       aes(lon, lev)) +
   geom_contour_fill(aes(z = gh), breaks = AnchorBreaks(0, binwidth, 0)) +
   geom_contour3(aes(z = gh), breaks = AnchorBreaks(0, binwidth, 0)) +
   scale_y_level(breaks = lev.breaks) +
   scale_x_longitude(name = "lon") +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), 
                        name = "QS3",
                        guide = guide_colorstrip_bottom()) +
   facet_wrap(~season, ncol = 2) 
```


Now this has some problems... yada yada yada, alternative analysis. 

# New seasons
```{r calc-qs.eof}
region <- expand.grid(lat = c(-65, -40),
                      lev = c(100, 700))
lats.eof <- c(-80, -30)
qs.eof <- copy(ncep[lev == 200 & lat %between% lats.eof]) %>%
   .[, gh.minus := FilterWave(gh, k = 0:-1), by = .(lat, time, lev)] %>% 
   .[, gh := gh.minus*sqrt(cos(lat*pi/180))] %>%
   .[, gh := Detrend(gh, time),
     by = .(lon, lat)] %>%
   EOF(data = ., gh ~ time | lon + lat, n = 1:10, B = 5000)

qs.eof$right[PC == "PC1", gh := -gh]
qs.eof$left[PC == "PC1", gh := -gh]
```


```{r eof4-ncep, fig.cap = "First 4 EOFs derived from the 200hPa detrended geopotential zonal anomaly field between 30°S and 80°S with zonal wave 1 filtered out. Erros bars represent the 95% cuantile range estimated via bootstrap."}
qs.eof$sdev %>% 
   ggplot(aes(as.numeric(PC), sd)) +
   geom_point() +
   geom_line() +
   geom_errorbar(aes(ymin = lower, ymax = upper),
                 width = 0.3) +
   scale_x_continuous("PC", 
                      breaks = 1:20, minor_breaks = NULL) +
   scale_y_continuous("sigma")
```

```{r spatial-eofs, fig.cap = "EOFs"}
qs.eof <- CutEOF(qs.eof, 1:6)
pc.labeller <- function(qs.eof) {
   with(qs.eof$sdev, setNames(paste0(PC, " - ", scales::percent(r2)),
                              PC))
}

binwidth <- 0.01
ggplot(qs.eof$right, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh), xwrap = c(0, 360),
                     breaks = AnchorBreaks(0, binwidth, 0)) +
   geom_contour3(aes(z = gh), xwrap = c(0, 360),
                 breaks = AnchorBreaks(0, binwidth, 0)) +
   map.SH +
   geom_hline(yintercept = lats.eof, linetype = 2) +
   scale_s_map() +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), #) +
                        guide = guide_colorstrip_bottom()) +
   coord_quickmap(ylim = c(-90, -20)) +
   facet_wrap(~PC, ncol = 3, dir = "v", 
              labeller = labeller(PC = pc.labeller(qs.eof))) ->g
```


```{r fourier-eof, fig.cap = "Fourier decomposition by latitude of each EOF."}
qs.eof$right[, FitWave(gh, 2:4), by = .(lat, PC)]  %>%
   ggplot(aes(amplitude, lat)) +
   geom_path(aes(color = paste0("QS", k))) +
   scale_y_latitude(ticks = 15) +
   scale_x_continuous() +
   scale_color_brewer(palette = "Set1") +
   coord_fixed(1/900) +
   facet_wrap(~PC, ncol = 3, dir = "v", 
              labeller = labeller(PC = pc.labeller(qs.eof)))
```


This text is no longer valid: 

PC1 to PC4 represent the principal modes of variability of the geopotential field with wavenumber greater than 1...

PC1 and PC2 both are dominated by a wave 3 pattern. They both explain an almost equal proportion of the total variance and represent a wave 3 pattern offset by 1/4 wavelength. From that, one can infer that they are degenerated modes that represent the same wave pattern and it's meridional movement. PC3 is mainly a hemispheric scale wave 2 with a small contribution of wave 4 north of 45°S. PC4 exhibits a more complex pattern with both waves 2 and 3 contributing to the field. The result is a wave 3-ish pattern on the eastern hemisphere that affects the Atlantic and the Indian oceans but disappears over the central-south Pacific.

This result suggest that the ZW3 could be represented by a linear combination of PC1 and PC2 at the same time preserving it's meridional propagation and zonal variation.

```{r PC1-PC2-trim, fig.cap = "Monthly mean values for each PC. Colors and shapes divide months into 5 'seasons'."}
qs.eof$left %>% 
   .[qs.eof$sdev, on = "PC"] %>% 
   .[, .(value = mean(gh*sd)), by = .(PC, month(time))] %>%
   dcast(... ~ PC) %>%
   ggplot(aes(PC1, PC2)) +
   # xlab("PC 1") + ylab("PC 2") +
   geom_cross(color = "gray50") +
   ggforce::geom_link2(aes(color = qs.season(month),
                           group = 1),
                       alpha = 0.5) +
   geom_point(aes(color = qs.season(month), shape = qs.season(month)),
              size = 3)+
   ggrepel::geom_text_repel(aes(label = month.abb[month])) +
   scale_color_brewer(palette = "Set1", na.translate = F) +
   ggthemes::scale_shape_circlefill() +
   guides(color = "none", shape = "none") +
   coord_equal()
```

```{r cluster, fig.cap = "Hierarchical clustering of the months of the year according to the mean value of each PC scaled by it's variance."}
qs.eof$left %>% 
   .[qs.eof$sdev, on = "PC"] %>% 
   .[, .(value = mean(gh*sd)), by = .(PC, month(time))] %>%
   dcast(month ~ PC, value.var = "value") %>% 
   .[, -1] %>% 
   dist() %>%
   hclust() %>% 
   plot(labels = month.abb, hang = -1) 
```


```{r PC1-PC2-trim-sd, fig.cap = "Monthly standard deviation for each PC. Colors and shapes divide months into 5 'seasons'."}
qs.eof$left %>% 
   .[qs.eof$sdev, on = "PC"] %>% 
   .[, .(value = sd(gh*sd)), by = .(PC, month(time))] %>%
   dcast(... ~ PC) %>%
   ggplot(aes(PC1, PC2)) +
   # xlab("PC 1") + ylab("PC 2") +
   geom_cross(color = "gray50") +
   ggforce::geom_link2(aes(color = qs.sem(month),
                           group = 1),
                       alpha = 0.5) +
   geom_point(aes(color = qs.sem(month), shape = qs.sem(month)),
              size = 3)+
   ggrepel::geom_text_repel(aes(label = month.abb[month])) +
   scale_color_brewer(palette = "Set1", na.translate = F) +
   ggthemes::scale_shape_circlefill() +
   guides(color = "none", shape = "none") +
   coord_equal()
```


```{r cluster-sd, fig.cap = "Hierarchical clustering of the months of the year according to the standard deviation of each PC scaled by it's variance."}
qs.eof$left %>% 
   .[qs.eof$sdev, on = "PC"] %>% 
   .[, .(value = sd(gh*sd)), by = .(PC, month(time))] %>%
   dcast(month ~ PC, value.var = "value") %>% 
   .[, -1] %>% 
   dist() %>%
   hclust() %>% 
   plot(labels = month.abb, hang = -1) 
```


```{r eof-boxplot, fig.cap = "Sesonal cycle of each PC"}
qs.eof$left %>%
   .[qs.eof$sdev, on = "PC"] %>% 
   CutEOF(1:2) %>% 
   ggplot(aes(factor(month(time)), gh*sd)) +
   geom_hline(yintercept = 0) +
   geom_boxplot(aes(color = PC), fill = "gray80", alpha = 0.2) +
   
   scale_y_continuous("Value") +
   scale_x_discrete("Month", labels = month.abb) 
```




An optimal (if somewhat arbitrary) division of the year can be seen in Figure X based on monthly mean values of each PC...


Notes: 

- Making other (still sensible) decisions lead to some differences in clustering. For example, using fields with QS1 *and* QS2 filtered out puts May closer to April, and December further from JFM. Not surprisingly, a similar result is achieved by using using idealized fields from the reconstructed zonal wave 3 (since higher wavenumbers explain a negligible proportion of the viariance). JFM and ASO (and it's similarity with April), on the other hand, are robust trimesters.

- This differences imply that the ZW2 might be have an important role in the variability in May and December. 

- JJ is a relatively robust grouping but with obviously more heterogeneous than JFM or ASO

- Futhermore, removing the linear trend as well as the QS1 field results in a similar classification to the one shown, but the structure of the EOF is slightly different with less separation between wavenumbers (the zonal wave 3 is present in PC1, PC2 and PC3) and a much more asymmetric nature, with higher amplitude anomalies on the western hemisphere than the eastern in the first two PCs and the reverse on the second two. Is it as the wave activity of each hemosphere is separated this way. 


```{r calc-events}
events <- qs.eof$left %>%
   .[, gh.norm := gh/sd(gh), by = PC] %>% 
   .[, event := cut(gh.norm, c(-Inf, -0.5, 0.5, Inf), 
                    c("negative", "neutral", "positive" ))] %>% 
   .[, event := factor(event, ordered = TRUE,
                       levels = c("positive", "neutral", "negative"))] %>% 
   CutEOF(1:2) %>% 
   .[, .(time, PC, event)] 

events.number <- events %>% 
   .[, .N, by = .(month(time), event, PC)] %>% 
   tidyr::complete(month, PC, event, fill = list(N = 0)) %>% 
   setDT() %>% 
   .[event != "neutral"] %>% 
   .[as.numeric(PC) %in% 1:2]

g <- events %>%
   .[ncep, on = c("time"), allow.cartesian = TRUE] %>%
   .[, .(gh = mean(gh)), by = .(lon, lat, month(time), event, PC)] %>% 
   dcast(lon + lat + month + PC ~ event, value.var = "gh") %>% 
   .[, `:=`(positive = positive - neutral, 
            negative = negative - neutral,
            neutral = NULL)]  %>% 
   melt(id.vars = c("lon", "lat", "month", "PC"), 
        variable.name = "event") %>% 
   .[events.number, on = c("month", "PC", "event")] %>% 
   # .[PC == "PC1"] %>%
   # .[month == 1] %>%
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = value), breaks = AnchorBreaks(0, 20, 0)) +
   map.SH +
   stat_subset(aes(subset = lon == 60 & lat == -20, 
                   label = paste0("N = ", N)),
               geom = "label", size = 2) +
   scale_s_map() +
   coord_quickmap() +
   scale_fill_divergent(breaks = AnchorBreaks(0, 20, 0),
                        guide = guide_colorstrip_bottom())
```

```{r number-of-events, fig.cap = "Number of positive and negative events (+- 0.5 sigma) for each PC and each month."}
ggplot(events.number, aes(month, N)) +
   # geom_area(aes(ymax = N, fill = event), 
   #           position = "dodge", alpha = 0.5) +
   geom_line(aes(color = event)) +
   scale_color_brewer(palette = "Set1") +
   scale_x_continuous("Month", 1:12, labels = month.abb) +
   scale_y_continuous("# of events", limits = c(0, NA)) +
   facet_wrap(~PC, ncol = 1)
```

```{r comp-events-1, fig.cap = "Mean gh anomaly (positive - neutral; negative - neutral) for positive and negatives events for each PC and each month."}
g + facet_grid_paginate(month ~ PC + event, ncol = 4, 
                        nrow = 6, page = 1,
                        labeller = labeller(month = month.abb))
```

```{r comp-events-2, fig.cap = "Mean gh anomaly (positive - neutral; negative - neutral) for positive and negatives events for each PC and each month. (continued)"}
g + facet_grid_paginate(month ~ PC + event, ncol = 4, 
                        nrow = 6, page = 2,
                        labeller = labeller(month = month.abb))
```

# Regressions

```{r calc-gh.cor}
qs.eof$left <- qs.eof$left[, gh.sd := gh/sd(gh), by = .(PC)]

qs.eof$left %>% 
   copy() %>% 
   .[, .(gh.eof = mean(gh.sd)), 
     by = .(PC, season = qs.sem(time), year(time))] %>% 
   .[!is.na(season)] %>% 
   CutEOF(1:2) %>% 
   dcast(year + season ~ PC, value.var = "gh.eof") -> eof.sem

ncep[lev == 200, .(gh = mean(gh)), 
     by = .(lon, lat, year(time), 
            season = qs.sem(time))] %>% 
   .[!is.na(season)] %>% 
   .[, gh := Detrend(gh), by = .(lon, lat, season)] -> gh.sem 


# Regresión de PCs estandarizados con anomalía trimestral,
# (1 dato por trimestre por año)
gh.regr <- gh.sem[eof.sem,  
                  on = c("season", "year"), 
                  allow.cartesian = TRUE] %>% 
   .[, FitLm(gh, PC1, PC2, se = TRUE), 
     by = .(lon, lat, season)] %>% 
   .[regressor != "mean"]

# remove(ncep)
```


```{r gh-regr, fig.cap = "(standarized) Regression between PCs and gh."}
binwidth <- 20
ggplot(gh.regr, aes(lon, lat)) +
   # geom_contour2(aes(z = -value, linetype = factor(-sign(..level..))),
   # breaks = AnchorBreaks(0, 0.15, 0), color = "black") +
   geom_contour_fill(aes(z = estimate), xwrap = c(0, 360),
                     breaks = AnchorBreaks(0, binwidth, 0)) +
   geom_contour3(aes(z = estimate), xwrap = c(0, 360),
                 breaks = AnchorBreaks(0, binwidth, 0)) +
   map.SH +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0),
                        guide = guide_colorstrip_bottom()) +
   scale_s_map() +
   coord_quickmap() +
   facet_grid(regressor ~ season)
```

```{r read-psi}
subset <- list(lat = -90:40,
               time = lubridate::as_datetime(c("1979-12-01",
                                               "2016-02-01")))
stream <- ReadNetCDF("DATA/stream.mon.mean.nc",
                     subset = subset, key = TRUE) %>%
   setnames(c("level"), c("lev")) %>%
   .[, time := as.Date(time[1]), by = time] %>% 
   .[, psi.z := Anomaly(psi), by = .(lat, time)]

stream.mean.season <- stream[, .(psi = mean(psi),
                                 psi.z = mean(psi.z)),
                             by = .(lon, lat, lev, season = qs.sem(time))] %>% 
   .[!is.na(season)]
stream.mean.season[, c("f.lon", "f.lat") := WaveFlux(.SD), by = season]
```

```{r calc-psi.regr}
stream %>% 
   .[!is.na(qs.sem(time)), 
     .(psi = mean(psi)), by = .(lon, lat, year(time),
                                season = qs.sem(time))] %>% 
   .[, psi.a := Detrend(psi), by = .(lon, lat, season)] -> stream.sem

# Regresión de PCs estandarizados con anomalía trimestral,
# (1 dato por trimestre por año)
stream.sem[eof.sem, on = c("season", "year")] %>% 
   .[complete.cases(.)] %>% 
   .[, FitLm(psi.a, PC1, PC2),
     by = .(lon, lat, season)] %>% 
   .[regressor != "mean"] -> psi.regr

# Regresión de PCs estandarizados con anomalía mensual, agregados
# trimestralmente (~3 datos por año por trimestre)
qs.eof$left %>% CutEOF(1:2) %>% 
   dcast(time ~ PC, value.var = "gh.sd") %>%
   .[stream, on = "time"] %>%
   .[, psi := Anomaly(psi), by = .(lon, lat, month(time))] %>% 
   .[!is.na(qs.sem(time)),
     FitLm(psi, PC1, PC2),
     by = .(lon, lat, season = qs.sem(time))] %>% 
   .[regressor != "mean"] -> psi.regr.month

psi.regr <- rbindlist(list(point = psi.regr,
                           full = psi.regr.month),
                      use.names = TRUE,
                      idcol = "method") %>%  
   .[, psi.z := estimate] %>% 
   .[, c("f.lon", "f.lat") := WaveFlux(.SD), 
     by = .(regressor, season, method)] 
```


```{r psi.regr, fig.cap = "Regression between PCs and Psi. "}
binwidth <- 0.0015
ggplot(psi.regr, aes(lon, lat)) +
   geom_contour_fill(aes(z = psi.z*10^-9),
                     breaks = AnchorBreaks(0, binwidth, 0),
                     # breaks = breaks,
                     xwrap = c(0, 360)) +
   geom_contour3(aes(z = psi.z*10^-9),
                 breaks = AnchorBreaks(0, binwidth, 0),
                 # breaks = breaks,
                 xwrap = c(0, 360)) +
   geom_streamline(aes(dx = f.lon, dy = f.lat), 
                   skip = 3, xwrap = c(0, 360), L = 10, size = 0.1, 
                   min.dist = 5, arrow.length = 0.2, arrow.angle = 10) +
   map.SH +
   scale_s_map(ylim = c(-90, 40)) +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0),
                        guide = guide_colorstrip_bottom()) +
   facet_grid(regressor + method  ~ season) +
   coord_quickmap(ylim = c(-90, 20))
```


```{r psi.regr2, fig.cap = "Zonal anomaly of regression between PCs and Psi."}
binwidth <- 0.0015
psi.regr %>% 
   .[, psi.z := Anomaly(estimate), by = .(lat, regressor, method, season)] %>% 
   .[, c("f.lon", "f.lat") := WaveFlux(.SD), 
     by = .(regressor, season, method)] 
ggplot(psi.regr, aes(lon, lat)) +
   geom_contour_fill(aes(z = psi.z*10^-9),
                     breaks = AnchorBreaks(0, binwidth, 0),
                     xwrap = c(0, 360)) +
   geom_contour3(aes(z = psi.z*10^-9),
                 breaks = AnchorBreaks(0, binwidth, 0),
                 xwrap = c(0, 360)) +
   geom_streamline(aes(dx = f.lon, dy = f.lat), 
                   skip = 3, xwrap = c(0, 360), L = 10, size = 0.1, 
                   min.dist = 5, arrow.length = 0.2, arrow.angle = 10) +
   map.SH +
   scale_s_map(ylim = c(-90, 40)) +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0),
                        guide = guide_colorstrip_bottom()) +
   facet_grid(regressor + method  ~ season) +
   coord_quickmap(ylim = c(-90, 20))
```


```{r read-ice}
ice <- readRDS("DATA/seaice.Rds")
ice.mask <- readRDS("DATA/landmask.Rds")
ice.mask <- setDT(tidyr::complete(ice.mask, x, y, 
                                  fill = list(concentration = 0)))
setnames(ice, "date", "time")

ice.sem <- ice[!is.na(qs.sem(time)), 
               .(concentration = mean(concentration)), 
               keyby = .(lon, lat, year(time), 
                         season = qs.sem(time))]

ice <- ice[!is.na(concentration)]
ice[, s := sum(concentration), by = .(x, y)]
ice <- ice[s >= 0.05]

ice[, concentration := Detrend(concentration), by = .(x, y, month(time))]

ice.eof <- ice[!is.na(qs.sem(time)), 
               EOF(concentration ~ x + y | time, n = 1:2)$left,
               by = .(season = qs.sem(time))]

ice.eof_time <- ice[!is.na(qs.sem(time)), 
                    EOF(concentration ~ x + y | time, n = 1:2)$right,
                    by = .(season = qs.sem(time))]

setnames(ice.eof, "PC", "regressor")

remove(ice)
ice.sem[, concentration.a := Detrend(concentration), 
        by = .(lon, lat, season)]
```

```{r calc-ice.regr}
ice.sem[eof.sem, on = c("season", "year")] %>% 
   .[complete.cases(.)] %>% 
   .[, FitLm(concentration.a, PC1, PC2, se = TRUE),
     by = .(lon, lat, season)] %>% 
   .[regressor != "mean"] -> ice.regr
```

```{r read-slp}
slp <- ReadNetCDF("DATA/slp.mon.mean.nc", subset = list(lat = -90:40))

slp.sem <- slp[!is.na(qs.sem(time)), 
               .(slp = mean(slp)), 
               by = .(lon, lat, year(time), season = qs.sem(time))]

slp.sem[, slp.a := Detrend(slp), by = .(lon, lat, season)]

eof.sem %>% 
   slp.sem[., on = c("season", "year")] %>% 
   .[complete.cases(.)] %>% 
   .[, FitLm(slp.a, PC1, PC2, se = TRUE), by = .(lon, lat, season)] %>% 
   .[regressor != "mean"] -> slp.regr
```


```{r ice-regr, fig.cap = "Regression of standarized PC with antarctic sea ice concentrations (shaded) and regression of standarized PC with SLP (contours)."}
binwidth <- 10

ggplot(ice.regr[lat < -55], aes(lon, lat)) +
   geom_point(aes(color = estimate*100), size = 0.05) +
   geom_contour3(data = slp.regr, aes(z = estimate),
                 breaks = AnchorBreaks(0, 1, 0), xwrap = c(0, 360)) +
   map.SH +
   scale_color_divergent(breaks = AnchorBreaks(0, binwidth, 0),
                         limits = c(-25, 25),
                         guide = guide_colorstrip_bottom()) +
   scale_s_map(ylim = c(-90, -40)) +
   coord_polar() +
   # coord_quickmap(ylim = c(-90, -55)) +
   facet_grid(regressor ~ season)
```

```{r ice-eof, fig.cap = "First 2 EOFs of antarctic sea ice concentration for each season (shaded) and regression of standarized PC (of geopotential) with 200hPa geopotential height (contours)" }
ice.eof[, y1 := as.numeric(-y + max(y))]
ice.eof[, x1 := - 3950*1000 + 2*3950*1000*x/316]
ice.eof[, y1 := - 3950*1000 + (4350+3950)*1000*y/332]
proj <- "+proj=stere +lat_0=-90 +lat_ts=-70 +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378273 +b=6356889.449 +units=m +no_defs"
ice.eof[, c("lon", "lat") := proj4::project(list(x1, y1), proj = proj, 
                                            inverse = TRUE)] -> ice.eof
ice.eof[, lon := ConvertLongitude(lon, from = 180)]

binwidth <- 0.01

ice.eof[lat < -55] %>% 
   ggplot(aes(lon, lat)) + 
   geom_point(aes(color = concentration), size = 0.05) +
   # geom_contour3(data = gh.regr, aes(z = estimate),
   #               breaks = AnchorBreaks(0, 25, 0), xwrap = c(0, 360)) +
   map.SH +
   scale_fill_divergent() +
   scale_color_divergent(breaks = AnchorBreaks(0, binwidth, 0),
                         # limits = c(-25, 25),
                         guide = guide_colorstrip_bottom()) +
   scale_s_map(ylim = c(-90, -55)) +
   coord_polar() +
   facet_grid(regressor~season)
```

```{r ice-east-west, fig.cap = "Mean sea ice concentration at the east of 90°W vs. at the west."}
ice.sem[,
        .(concentration.a = mean(concentration.a, na.rm = TRUE)), 
        by = .(year, season, 
               region = ifelse(lon %between% c(270, 330), "East",
                               ifelse(lon %between% c(190, 270), "West",
                                      NA)))] %>% 
   .[complete.cases(.)] %>% 
   dcast(year + season ~ region, value.var = "concentration.a") %>% 
   ggplot(aes(East, West)) +
   geom_point() +
   geom_smooth(method = "lm") +
   # geom_smooth(method = "theilsen", color = "red") +
   scale_x_continuous("Mean sea ice concentration \nbetween 90°O and 30°O") +
   scale_y_continuous("Mean sea ice concentration \nbetween 170°O and 90°O") +
   facet_wrap(~season)
```

```{r eof-ghice}
gh <- ReadNetCDF("DATA/hgt.mon.mean.nc", var = c(gh = "hgt"),
                 subset = list(level = 200))
gh[, time := as.Date(time[1]), by = time]

ice <- readRDS("DATA/seaice.Rds")
ice <- ice[!is.na(concentration), .(lon, lat, date, concentration)]
setnames(ice, "date", "time")

usable.range <- c(max(min(gh$time), min(ice$time)),
                  min(max(gh$time), max(ice$time)))

gh <- gh[time %between% usable.range]
ice <- ice[time %between% usable.range]

lats.eof <- c(-80, -30)
gh <- gh[lat %between% lats.eof] %>%
   .[, gh.minus := FilterWave(gh, k = 0:-1), by = .(lat, time)] %>% 
   .[, gh := gh.minus*sqrt(cos(lat*pi/180))] %>%
   .[, gh := Detrend(gh, time),
     by = .(lon, lat)] 

ghice <- rbindlist(list(ice = ice[, .(lon, lat, time, value = concentration)], 
                        gh = gh[, .(lon, lat, time, value = gh)]), 
                   idcol = "variable")
remove(ice, gh)

ghice[, value.a := Anomaly(value), by = .(lon, lat, variable, month(time))]
ghice[, value.a := value.a/sd(value.a), by = .(lon, lat, variable)]
ghice <- ghice[is.finite(value.a)]

# ghice[, value := value.a*sqrt(cost(lat*pi/180))]


ghic.eof <- EOF(value.a ~ lon + lat + variable | time, data = ghice, n = 1:4)
```

```{r gif-eoffhice, fig.cap = "Joint EOF of filtered geopotential height and antarctic sea ice concentration."}
ghic.eof$left %>% 
{
   ggplot(., aes(lon, lat)) +
      geom_point(aes(color = value.a), data = .[variable == "ice"], 
                 size = 0.1) +
      geom_contour2(aes(z = value.a), data = .[variable == "gh"], 
                    xwrap = c(0, 360)) +
      map.world +
      scale_s_map(ylim = c(-90, -20)) +
      scale_color_divergent() +
      facet_wrap(~PC)
}
```


```{r read-icedrift}
ice.drift <- readRDS("DATA/ice.drift.rda")
icemap <- unique(ice.drift[, .(x, y, lon, lat)])

# 25km resolution 321*321 grid centered in the south pole
ice.drift[, x := 25000*(x - 161)]
ice.drift[, y := 25000*(161 - y)]

icemap[, x := 25000*(x - 161)]
icemap[, y := 25000*(161 - y)]

proj <- "+proj=stere +lat_0=-90 +lat_ts=-70 +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378273 +b=6356889.449 +units=m +no_defs"
antarctica <- setDT(map_data("world", "Antarctica")) %>% 
   .[, c("x", "y") := proj4::project(list(long, lat),
                                     proj = proj)] %>% 
   geom_polygon(data = ., aes(x, y, group = group), 
                fill = "gray80", color = "black", size = 0.3)

ice.drift.sem <- ice.drift[, .(u = mean(u), v = mean(v)), 
                           by = .(x, y, year = year(time), 
                                  season = qs.sem(time))]

ice.drift.sem[, `:=`(u = Detrend(u), 
                     v = Detrend(v)), by = .(x, y, season)]

ice.drift.regr <- ice.drift.sem %>% 
   melt(id.vars = c("x", "y", "season", "year")) %>% 
   .[eof.sem, on = c("year", "season")] %>%
   .[, N := sum(!is.na(value)), by = .(x, y, season, variable)] %>% 
   .[N > 10] %>% 
   .[, FitLm(value/1000, PC1, PC2, se = TRUE), 
     by = .(x, y, season, variable)] %>% 
   .[regressor != "mean"]

regr.v <- ice.drift.sem %>% 
   icemap[., on = c("x", "y")] %>% 
   .[, v := u*sin(lon*pi/180) + v*cos(lon*pi/180)] %>% 
   .[eof.sem, on = c("year", "season")] %>%
   .[, N := sum(!is.na(v)), by = .(x, y, season)] %>% 
   .[N > 10] %>% 
   .[, FitLm(v/1000, PC1, PC2, se = TRUE), 
     by = .(x, y, season)] %>% 
   .[regressor != "mean"] %>% 
   .[, significant := prob.t(estimate, se, df)]
```

```{r circular_grid}
rads <- suppressWarnings(proj4::project(list(0, seq(-90, -60, by = 10)),
                                        proj)$y)

circular_grid <- function(r = rads, by = 45, n = 40, 
                          linetype = 2, 
                          color = "gray30", size = 0.3){
    list(
       geom_path(data = MakeCircle(r, n = n), aes(x, y, group = r),
                 linetype = linetype, color = color, size = size),
       geom_spoke(data = data.frame(rad = max(r), x = 0, y = 0,
                                    angle = pi/180*seq(0, 360, by = by)),
                  aes(x, y, radius = rad, angle = angle),
                   linetype = linetype, color = color, size = size)
       )
} 
```



```{r ice.drift-regr, fig.cap = "Regression of sea ice motion on each PC. The regression of the meridional component of sea icea motion is shown in color in areas ."}
ice.drift.regr %>% 
   # .[regressor == "PC1" & season == "MJJASON"] %>%
   .[, significant := prob.t(estimate, se, df)] %>% 
   dcast(x + y + season + regressor ~ variable, 
         value.var = c("estimate", "significant")) %>% 
   icemap[., on = c("x", "y")] %>%
   .[complete.cases(.)] %>%
   ggplot(aes(x, y)) +
   stat_subset(aes(subset = significant <= 0.025,
                   fill = estimate),
               geom = "raster", 
               data = regr.v) +
   geom_streamline(aes(dx = estimate_u, dy = estimate_v),
                   alpha = 0.3, min.dist = 7,
                   skip = 10, arrow.length = 0.4, L = 8e5) +
   antarctica +
   circular_grid() +
   scale_fill_divergent("V", 
                        limits = pm(0.025),
                        oob = scales::squish,
                        guide = guide_colorstrip_bottom()) +
   scale_x_continuous("") + scale_y_continuous("") +
   coord_equal() +
   theme(panel.grid = element_blank(), axis.line = element_blank(),
         axis.text = element_blank()) +
   facet_grid(regressor ~ season)
```




```{r read-sst}
sst <- ReadNetCDF("DATA/sst.nc", vars = "sst")
sst[, time := as.Date(time[1]), by = time]

sst.sem <- sst[!is.na(qs.sem(time)), 
               .(sst = mean(sst)), 
               keyby = .(lon, lat, year(time), 
                         season = qs.sem(time))] %>% 
   .[, sst.a := Anomaly(sst), by = .(lon, lat, season)]
```

```{r calc-sst.regr}
sst.sem[eof.sem, on = c("season", "year")] %>% 
   .[complete.cases(.)] %>% 
   .[, FitLm(sst.a, PC1, PC2, se = TRUE),
     by = .(lon, lat, season)] %>% 
   .[regressor != "mean"] -> sst.regr
```

```{r sst-regr, fig.cap = "Regression of standarized PC with SST."}
ggplot(sst.regr, aes(lon, lat)) +
   geom_raster(aes(fill = estimate)) +
   geom_contour3(aes(z = sign(estimate)*as.numeric(abs(estimate) > std.error*1.6)),
                 breaks = c(-0.5, 0.5), xwrap = c(0, 360)) +
   stat_subset(aes(subset =  abs(estimate) > std.error*2), geom = "point",
               alpha = 0.5, color = "black", size = 0.05,
               data = sst.regr[lon %in% JumpBy(unique(lon), 4) &
                                  lat %in% JumpBy(unique(lat), 4)]) +
   map.SH +
   scale_fill_divergent(guide = guide_colorstrip_bottom(),
                        breaks = AnchorBreaks(0, 0.5, 0)) +
   scale_s_map(ylim = c(-90, 30)) +
   coord_quickmap(ylim = c(-90, 30)) +
   facet_grid(season ~ regressor)
```


```{r read-oni}
oni <- fread("DATA/ONI_v5.csv") 
colnames(oni) <- c("year", 1:12)
oni <- melt(oni, id.vars = "year", variable.name = "month", 
            value.name = "ONI")
oni[, time := lubridate::ymd(paste0(year, "-", month, "-01"))]
oni[, c("year", "month") := NULL]
```

```{r enso-regr}
oni.sem <- oni[!is.na(qs.sem(time)), 
               .(ONI = mean(ONI)), 
               by = .(year(time), season = qs.sem(time))] %>% 
   .[, ONI.a := Anomaly(ONI), by = season]

eof.sem %>% 
   melt(id.vars = c("year", "season"), variable.name = "PC") %>%
   oni.sem[., on = c("season", "year")] %>% 
   .[complete.cases(.)] %>% 
   .[,  broom::tidy(cor.test(value, ONI)),
     by = .(season, PC)] %>% 
   .[PC == "PC1"] %>% 
   dcast(season ~ PC, value.var = c("estimate", "p.value")) %>% 
   knitr::kable(digits = c(1, 2, 9), 
                caption = "Correlation between ONI and PC1")
```


```{r eof-enso, fig.cap = "Relationship between PC1 and PC2 with ONI anomalies."}
eof.sem %>% 
   melt(id.vars = c("year", "season"), variable.name = "PC") %>%
   oni.sem[., on = c("season", "year")] %>% 
   ggplot(aes(ONI.a, value)) +
   geom_point() +
   geom_smooth(method = "lm") +
   facet_grid(season ~ PC)
```

```{r sam.sem, fig.cap = "Relationship between PC1 and PC2 and SAM."}
sam <- fread("DATA/sam.monthly.txt")
colnames(sam) <- c("year", "month", "sam")
sam.sem <- sam[!is.na(qs.sem(month)), 
               .(sam = mean(sam)), 
               by = .(year, season = qs.sem(month))]

eof.sem %>% 
   melt(id.vars = c("year", "season"), variable.name = "PC") %>%
   sam.sem[., on = c("season", "year")] %>% 
   ggplot(aes(sam, value)) +
   geom_point() +
   geom_smooth(method = "lm") +
   facet_grid(season ~ PC)
```


# QS3

```{r calc-qs3eof}
qs3 <- ncep.f(level = 200, lat = -65:-40) %>% 
   .[, FitWave(gh, 3), by = .(time, lat)] %>% 
   .[, .(amplitude = mean(amplitude),
         phase = .SD[amplitude == max(amplitude)]$phase), 
     by = .(time)]

qs3 <- qs.eof$left %>% 
   .[qs.eof$sdev[, .(PC, sd)], on = "PC"] %>% 
   .[, gh := gh*sd] %>% 
   CutEOF(1:4) %>% 
   dcast(time ~ PC, value.var = "gh") %>% 
   .[qs3, on = "time"]

compl <- ncep.f(level = 200, lat = -65:-40) %>% 
   .[, fft2(gh, 3), by = .(time, lat)] %>% 
   .[, .(R = mean(R), I = mean(I)), by = time]

compl <- qs.eof$left %>% 
   .[qs.eof$sdev[, .(PC, sd)], on = "PC"] %>% 
   .[, gh := gh*sd] %>% 
   CutEOF(1:4) %>% 
   dcast(time ~ PC, value.var = "gh") %>% 
   .[compl, on = "time"]
```


```{r pc12-ampl, fig.cap = "Relationship between wave 3 amplitude and the first 2 principal components."}
qs3[, .(time, PC1, PC2, amplitude)] %>% 
   melt(id.vars = c("time", "amplitude"), variable.name = "PC") %>% 
   ggplot(aes(amplitude, value)) +
   geom_point(size = 0.5, alpha = 0.5) +
   geom_smooth() + 
   scale_color_brewer(palette = "Set1") +
   scale_x_continuous("Wave 3 amplitude") + 
   scale_y_continuous("PC Value") +
   facet_wrap(~PC, ncol = 1)
```


```{r qs3-eof, fig.cap = "Relationship between 2 first EOFs and amplitude of wave 3. a) Monthly mean wave 3 amplitude as a function of PC1 and PC2; contours represent a smooth surface from data points b) Amplitude of monthly mean wave 3 amplitude as a function of PC1 and PC2 magnitude; line is a loess smooth."}

quantiles <- c(.05, 0.25, 0.5, 0.75, 0.95)
b <- quantile(qs3$amplitude, quantiles)

quantile_breaks <- function(probs = seq(0, 1, 0.25), ...) {
   function(x) {
      quantile(x, probs, ...)
   }
}

model <- nls(amplitude ~ a0 + a*sqrt((PC1 - p1_0)^2 + (PC2 - p2_0)^2), 
             data = qs3) 
cm <- as.list(coef(model)) 

p1 <- ggplot(qs3, aes(PC1, PC2)) +
   geom_cross(size = 0.2) +
   stat_rasa(aes(z = amplitude, color = ..level..),
             fun = SmoothContour,
             geom = "contour2", smooth = 0.07,
             breaks = b) +
   # geom_contour(data = grid, aes(z = amplitude, color = ..level..),
   #              binwidth = 10) +
   geom_point(aes(color = amplitude), size = 0.4) +
   scale_color_viridis_c(breaks = b,
                         limits = range(b),
                         guide = guide_colorstrip_bottom(10, 
                                                         inside = TRUE),
                         oob = scales::squish) +
   scale_x_continuous(expand = c(0, 0)) + 
   scale_y_continuous(expand = c(0, 0)) +
   # coord_cartesian(ylim = c(-2000, 2000),
   # xlim = c(-2000, 2000)) +
   coord_equal() +
   labs(tag = "a")  

p2 <- ggplot(qs3, aes(sqrt(PC1^2 + PC2^2), amplitude)) +
   geom_point(alpha = 0.5, size = 0.5) +
   # geom_abline() +
   geom_smooth(method = "loess", formula = y ~ x,
               color = "black", se = T) +
   # geom_line(data = grid) +
   scale_x_continuous(expression(sqrt(PC1^2 + PC2^2))) +
   scale_y_continuous("Wave 3 amplitude") +
   labs(tag = "b") 
p1 + p2
set_last_plot(p1 + p2)
```

```{r phase-PCs, fig.cap = "Phase of zonal wave 3 and value of PCs 1 to 2. The line is a loess smooth."}
smoothcircular <- function(data, range = c(0, 360), span = 0.75, n = 50) {
   data <- rbindlist(list(left = data,
                          mid = data,
                          right = data), 
                     idcol = "side")
   
   setDT(data)
   data[side == "right", x := x + diff(range)]
   data[side == "left", x := x - diff(range)]
   
   x <- seq(min(range), max(range), length.out = n)
   if (max(x) != max(range)) x[n+1] <- max(range)
   
   grid <- data.frame(x = x)
   grid$y <- predict(loess(y ~ x, data = data, span = span), grid)
   grid
}

qs3[, .(time, PC1, PC2, phase, A = Mag(PC2, PC1))] %>% 
   melt(id.vars = c("time", "phase", "A"), variable.name = "PC") %>% 
   ggplot(aes(phase*180/pi, value, color = PC)) +
   geom_point(size = 0.5, alpha = 0.5) +
   # geom_smooth(span = 0.15*3) +
   stat_rasa(fun = smoothcircular, geom = "line", span = 0.15,
             range = c(0, 360/3)) +
   scale_color_brewer(palette = "Set1") +
   scale_x_continuous("Phase", 
                      breaks = seq(0, 360/3, by = 15),
                      limits = c(0, 360/3), 
                      expand = c(0, 0)) +
   scale_y_continuous("PC Value") #+ coord_polar() #+  facet_wrap(~PC)
```



```{r phase-angle, fig.cap = "Relationship between wave 3 phase and angle between PC2 and PC1. Points to the left of the left dotted line are duplicates from the right of the right dotted line. Dashed line is the x = y line and solid line is a linear fit based on the Theil-Sen estimator."}
shift <- 45
qs3 %>% copy() %>% 
   .[, pc.angle := ConvertLongitude(atan2(PC2-cm$p2_0,
                                          PC1-cm$p1_0)*180/pi) + shift] %>% 
   .[, phase := phase*180*3/pi] %>% 
   rbind(.,., idcol = TRUE) %>%
   .[.id == 1, pc.angle := pc.angle-360] %>%
   .[pc.angle %between% c(-10, 360 + shift)] %>%
   .[, dupl := .id == 2] %>% 
   ggplot(aes(pc.angle, phase)) + 
   geom_point(size = 0.4) +
   geom_abline(linetype = 2) +
   geom_smooth(method = "theilsen", color = "black") +
   geom_vline(xintercept = c(shift, 350), linetype = 3) +
   scale_y_continuous("Phase x 3 (degrees)") +
   scale_x_continuous(expression(tan^{-1}~((PC2-p2[0])/(PC1-p1[0])) + shift)) +
   coord_equal()
```


The first two principal modes are closely related to the zonal wave 3. In fact, it can be shown that they define a rotation of the complex plane defined by the real an imaginary part of the wave3 fourier transform. 

```{r angle-table}
a1 <- coef(lm(PC1 ~ R + I -1, data = compl))
a2 <- coef(lm(PC2 ~ R + I -1, data = compl))

a1 <- coef(lm(R ~ PC1 + PC2 -1, data = compl))
a2 <- coef(lm(I ~ PC1 + PC2 -1, data = compl))

angles <- as.data.table(rbind(a1, a2))
angles[, PC := c("PC1", "PC2")]
angles[, PC := c("R", "I")]
setcolorder(angles, c(3, 1:2))

knitr::kable(angles)
```

```{r vectors, fig.cap = "Angle between PC1 and PC2 and Real and Imaginary part of wave 3"}
ggplot(angles, aes(PC1, PC2)) +
   geom_segment(aes(x = 0, y = 0, xend = PC1, yend = PC2), 
                arrow = grid::arrow()) +
   coord_equal() 
```

