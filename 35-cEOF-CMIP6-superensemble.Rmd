---
title: "35-cEOF Superensamble"
author: "Elio Campitelli"
output: 
   bookdown::html_document2:
         base_format: tufte::tufte_html 
         css: tabset.css
link-citations: yes 
---

<SCRIPT language="JavaScript" SRC="tabset.js"></SCRIPT>


```{r setup, include=FALSE}
# Notification
start.time <- unclass(Sys.time())
min.time <- 10
knit_doc <- knitr::knit_hooks$get("document")

options(htmltools.dir.version = FALSE)
# knitr::knit_hooks$set(document = function(x) {
#    took <- unclass(Sys.time()) - start.time
#    if (unclass(Sys.time()) - start.time >= min.time) {
#       notify("Done knitting!", 
#              paste0("Took ", round(took), " seconds"),
#              time = 5)
#    }  
#    knit_doc(x)
# })


# name <- tools::file_path_sans_ext(knitr::current_input())
name <- "35-cEOF-CMIP6-superensemble"
knitr::opts_chunk$set(
   echo = FALSE,
   fig.path = paste0("fig/", name, "/"),
   message = TRUE,
   warning = FALSE,
   message = FALSE,
   cache = TRUE, 
   cache.lazy = FALSE,
   cache.extra = 42,
   cache.path = paste0("cache/", name, "/")
)

knitr::opts_hooks$set(label = function(options) {
   if (is.null(options$fig.cap)) {
      options$fig.cap <- paste0("(ref:", options$label, "-cap)")
   }
   options
})

cache <- cachem::cache_disk(file.path("cache", name, "memoise"))

library(data.table)
library(magrittr)
library(ggplot2)
library(metR)
library(gt)
library(tagger)
library(tidyfast)
library(rcmip6)
source("scripts/fftspectrum.R")
source("scripts/helperfun.R")
D <- `[`

factor_ReIm <- function(part) {
   factor(part, levels = c("Real", "Imaginary"), ordered = TRUE)
}

ReIm <- function(complex) {
   list(Real = Re(complex), Imaginary = Im(complex))
}

sep_ReIm <- function(data, column, format = c("longer", "wider")) {
   R <- part <- I <- NULL
   names <- c("Real", "Imaginary")
   
   
   if (missing(column)) {
      complex <- vapply(data, function(x) inherits(x, "complex"), TRUE)
      if (sum(complex) > 1) {
         stop("`column` missing and more than one complex column found")
      }
      if (sum(complex) == 0) {
         warning("`column` missing and no complex column found. Returning unchanged data")
         return(data)
      }
      
      col <- colnames(data)[complex]
   } else {
      col <- deparse(substitute(column))
   }
   
   
   data <- data.table::copy(data)[, (names) := ReIm(get(col))]
   
   
   if (format[1] == "longer") {
      data[, c(col) := NULL]
      data <- data.table::setDT(tidyr::pivot_longer(data, Real:Imaginary, names_to = "part", values_to = col))
      data[, part := factor(part, levels = names, ordered = TRUE)]
   }
   
   return(data[])
}

source("scripts/theme.R")
theme_set(theme_elio())
guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
   ggplot2::guide_colorstrip(title.position = "top", title.hjust = 0.5,
                             barheight = height,
                             barwidth = width, ...)
}

sink <- capture.output(sf::sf_use_s2(FALSE))
geom_qmap <- function(subset = identity,
                      crop = NULL,
                      color = "gray50", size = 0.3,
                      fill = NA, wrap = c(0, 360), weighting = 0.7,
                      keep = 0.015, ...) {
   lon <- lat <- group <- NULL
   data <- map_simple(wrap = wrap, keep  = keep, weighting = weighting)
   
   if (!is.null(crop)) {
      bbox <- sf::st_bbox(data)
      
      for (n in names(crop)) {
         bbox[[n]] <- crop[[n]]
      }
      
      data <- suppressWarnings(suppressMessages(sf::st_crop(data, bbox)))
   }
   
   
   subset <- purrr::as_mapper(subset)
   data <- subset(data)
   
   ggplot2::geom_sf(data = data,
                    inherit.aes = FALSE,
                    color = color,
                    size = size,
                    fill = fill,
                    ...)
   
}

map_simple <- function(wrap = c(0, 360), keep = 0.015, weighting = 0.7) {
   map <- maps::map("world", fill = TRUE,
                    col = "transparent", plot = FALSE, wrap = wrap)
   map <- sf::st_as_sf(map)
   if (keep != 1) {
      map <- rmapshaper::ms_simplify(map, keep = keep, weighting = weighting)
   }
   
   
   map
}

height <- GetTopography(0, 180-1.5, 10.5, -89, resolution = 1.5, 
                        file.dir = file.path("cache", name)) %>% 
   rbind(GetTopography(180+1.5, 360, 10.5, -89, resolution = 1.5,
                       file.dir = file.path("cache", name))) %>% 
   as.data.table()


coord_polar <- function(ymax = -20, ...) {
   
   x <- c(seq(0, 360, length.out = 40), 
          seq(360, 0, length.out = 40), 
          0)
   y <- c(rep(ymax, length.out = 40), 
          rep(60, length.out = 40), 
          ymax)
   
   cbind(x, y) %>% 
      list() %>% 
      sf::st_polygon() %>% 
      sf::st_sfc(crs = "+proj=latlong") -> white
   
   list(
      geom_sf(data = white, inherit.aes = FALSE, 
              fill = "white", 
              colour = "white", size = 2),
      coord_sf(ylim = c(-90, ymax), 
               lims_method = "box",
               crs = "+proj=laea +lat_0=-90",
               default_crs = "+proj=longlat",
               label_axes =  "----", ...)
   )
}

periodic_lon <- function(data) {
   m_lon <- min(data$lon)
   range <- c(0, 360) + m_lon
   range2 <- c(0 - m_lon, 360) 
   
   ggperiodic::periodic(data, lon = range) %>% 
      ggperiodic::wrap(lon = range2)
}


n_eof <- 2

climatology <- as.Date(c("1985-01-01", "2014-12-31"))

is.enso34 <- function(lon, lat) {
   (abs(lat) < 5) & (ConvertLongitude(lon) %between% c(-170, -120))
}
```


```{r cmip_available}
# Tuve que optimizar algunas cosas para poder parsear miles de archivos
cmip_available <- function(..., root = cmip_root_get()) {
   template <- rcmip6:::cmip6_folder_template %>% 
      gsub("\\%\\(", "{", .) %>% 
      gsub("\\)s", "}", .)
   
   vars <- template %>% 
      gsub("\\{", "", .) %>% 
      gsub("\\}", "", .) %>% 
      strsplit("/") %>% 
      .[[1]]
   
   
   search_null <- rep("*", length(vars)) %>% 
      setNames(vars) %>% 
      as.list()
   
   globulate <- function(x) {
      if (length(x) > 1) {
         paste0("@(", paste0(unique(x), collapse = "|"), ")")   
      } else {
         x
      }
   }
   
   search <- list(...)
   for (name in names(search)) {
      search_null[[name]] <- search[[name]]
   }
   search <- search_null
   
   search <- lapply(search, globulate)
   
   # Hay que asegurarse de correr en bash
   command <- paste0("ls -f ", paste0(root, "/", glue::glue_data(search, template), "/model.info"))
   command <- paste0("shopt -s extglob\n ls -f ", 
                     paste0(root, "/", glue::glue_data(search, template), "/model.info"))
   script_file <- tempfile()
   writeLines(command, script_file)
   
   info <- system(paste0("/bin/bash  ", script_file), intern = TRUE)
   
   info <- normalizePath(info)
   
   data <- unglue::unglue_data(gsub(cmip_root_get(), "", dirname(info)),
                               template)
   
   
   files <- lapply(info, function(info) {
      Sys.glob(paste0(dirname(info), "/*nc"))
   })
   data$files <- files
   
   return(data)
}
```


```{r sims}
cmip_root_set("/shera/datos/CMIP/")
sims <- cmip_available(mip_era = "CMIP6", 
                       activity_drs = "CMIP",
                       experiment_id = "historical",
                       # source_id = unique(simulaciones$model),
                       table_id = c("Amon", "Omon"),
                       variable_id = c("zg", "tos")) %>% 
   as.data.table() %>% 
   .[, version := as.numeric(version)] %>% 
   .[, c("ensemble", "init", "physics", "forcing") := as.list(unglue::unglue_data(member_id, "r{ensemble}i{init}p{physics}f{forcing}", convert = TRUE))] %>% 
   .[order(ensemble)]

# Algunos modelos tienen distintas parametrizaciones, inicializaciones y demás. 
# Me quedo sólo con una combinación para no volverme loque. 
sims <- sims[, .SD[physics == physics[1] & init == init[1] & forcing == forcing[1]],
             by =  .(source_id, variable_id)] %>% 
   .[, .SD[uniqueN(ensemble) >= 5], by = source_id]

# El miembro 3 de EC-Earth3 me da problemas por alguna razón
# cdo mergtime me dice "structure not supported" o algo así. 
sims <- sims[!(source_id == "EC-Earth3" & ensemble == 3)]

# EC-Earth3 da muchos problemas. Los miembros no tienen todos el mismo
# rango de fechas y eso ya me da errores más abajo... se va.
sims <- sims[!(source_id == "EC-Earth3")]

# ICON-ESM-LR no tiene una grilla lon lat. Tiene una coordenada
# i que identifica el punto de grilla.
sims <- sims[source_id != "ICON-ESM-LR"]

# Me quedo con la "mejor grilla". Esto afecta únicamente 
# a tos (sst).
# El orden de preferencia de las grillas es 
# medio aleatorio; gn es el más común.
grid_order <- c("gn", "gr", "gr1")

sims <- sims %>% 
   copy() %>% 
   .[, grid_label := factor(grid_label, levels = grid_order, ordered = TRUE)] %>% 
   .[order(grid_label)] %>%
   .[, .SD[grid_label == grid_label[1]], by = .(source_id, ensemble, variable_id)] 
```


```{r select_merge}
future::plan("multisession")
select_merge <- function(file_in) {
   
   unique_items <- file_in %>% 
      basename() %>% 
      unglue::unglue_data("{variable}_{mean}_{model}_historical_r{member}i{init}p{physics}f{forcing}_{grid}_{start_date}-{end_date}.nc") %>% 
      as.data.table() %>% 
      .[, ":="(start_date = NULL, end_date = NULL)] %>% 
      unique() %>% 
      nrow()
   
   browser(expr = unique_items != 1)
   # stopifnot(unique_items == 1)
   
   file_out <- file.path("cmip_son", basename(file_in[1]))
   
   if (file.exists(file_out)) {
      return(file_out)
   }
   
   # Hay algunos archivos mal bajados. 
   nulos <- file.size(file_in) == 0
   if (any(nulos)) {
      warning("Archivo(s) nulos: \n", paste0(file_in[nulos], collapse = "\n"))
      return(NA_character_)
   }
   message("Procesando archivos ", basename(file_in[1]))
   var <- substr(basename(file_in[1]), 1, 1) 
   
   # Algunos modelos (IPSL) vienen con una grilla "genérica" en vez de lonlat
   to_regrid <- FALSE
   if (var == "t") {
      grid <- tempfile()
      invisible(capture.output(t <- system(paste0("cdo griddes ", file_in[1], " > ", grid), intern = TRUE)))
      if (length(grep("generic", readLines(grid))) != 0) {
         to_regrid <- TRUE
         invisible(capture.output(t <- system(paste0('sed -i "s/generic/lonlat/g" ', grid), intern = TRUE)))
      }
   }  
   
   
   # Selecciondo para cada archivito
   # TODO: hacer un hard stop si falla algún archivo. 
   # https://twitter.com/UbuntR314/status/1523761710548406272
   temp_files <- furrr::future_map_chr(file_in, function(file) {
      file_out <- tempfile(fileext = ".nc")
      
      if (to_regrid) {
         outfile <- tempfile(fileext = ".nc")
         invisible(capture.output(t <- system(paste0("cdo setgrid,", grid, " ", file, " ", outfile))))
         file <- outfile
      }
      if (var == "z") {
         select <- "-sellevel,20000,5000"
         remap <- NULL
      } else {
         select <- NULL
         # Paso sst a una grilla regular porque sino distintos modelos tienen distintas
         # grillas y es un quilombo procesarlos programáticamente.
         remap <- "-remapdis,r240x60" 
      }
      
      s <- capture.output(system(paste0("cdo ", select, " -timselmean,3 -select,season=SON ",
                                        remap, " ", 
                                        shQuote(file), " ", 
                                        shQuote(file_out)), 
                                 intern = TRUE))
      if (!file.exists(file_out)) {
         file_out <- NA_character_
      }
      
      return(file_out)
   })
   
   # y luego uno
   s <- system(paste0("cdo mergetime ", paste0(shQuote(temp_files), collapse = " "), " ",
                      shQuote(file_out)))
   
   if (s == 1) {
      return(NA_character_)
   }
   unlink(temp_files)
   return(file_out)
}
```


```{r merge}
files <- sims$files %>% 
   vapply(select_merge, character(1))
```

```{r simulaciones}
simulaciones <- na.omit(files) %>% 
   basename() %>% 
   unglue::unglue_data("{variable}_{mean}_{model}_historical_r{member}i{init}p{physics}f{forcing}_{grid}_{start_date}-{end_date}.nc", convert = TRUE) %>% 
   as.data.table() %>% 
   DT(, file := na.omit(files)) %>% 
   DT(order(variable, model, member))
```

# Métodos

Dada la experiencia anterior, voy a calcular los cEOFs usando todos los miembros concatenados: el superensemble (?). 

Algunos detalles:

- Medias estacionales de SON  
- Estandarizo cada nivel usando el desvio estándard de la climatología `r paste0(year(climatology), collapse = " -- ")`  
- Me quedo sólo con una inicialización, física y forzante por modelo.  
- Me quedo sólo con modelos con más de 5 miembros. 

En la Tabla \@ref(tab:descripcion) se listan todos los modelos y la cantidad de miembros de cada uno. 

```{r descripcion}
simulaciones %>% 
   .[, .(miembros = .N), by = .(model)] %>% 
   .[order(-miembros)] %>% 
   knitr::kable(caption = "Modelos disponibles.", col.names = c("Modelo", "# de miembros"))
```

Voy a calcular los cEOF multimodelo como los cEOFs promedio.

```{r era5}
era5 <- "/datos/reanalysis/ERA5/mon/era5.mon.mean.nc" %>% 
   ReadNetCDF(vars = c(hgt = "z"), 
              subset = list(lat = c(-90, 10), 
                            time = c("1979-01-01", "2014-12-31"),
                            lev = list(200, 50))) %>% 
   DT(season(time) == "SON") %>% 
   DT(, hgt := hgt/9.8) %>% 
   DT(, lev := as.integer(lev)) %>% 
   setnames("lev", "plev") %>% 
   DT(, .(hgt = mean(hgt)), by = .(lon, lat, plev, time = as.integer(year(time)))) %>% 
   DT(, model := "ERA5") %>%
   DT(, member := 1L) %>% 
   DT(is.finite(hgt)) %>% 
   DT(, hgt_z := hgt - mean(hgt), by = .(time, lat, plev)) 

set.seed(42)
ceof_era5 <-
   era5 %>% 
   DT(, hgt_z := hgt_z/sd(hgt_z[time %between% year(climatology)]), by = .(plev)) %>% 
   DT(, hgt_cplx := spectral::analyticFunction(hgt_z), by = .(time, plev, lat)) %>% 
   DT(, eof := hgt_cplx) %>% 
   DT(lat %between% c(-85, -20)) %>%
   DT(, .(eof = list(EOF(formula = eof ~ time + member | lon + lat + plev, n = 1:2, 
                         data = .SD, 
                         suffix = "cEOF"))), by = .(model))

ceof_era5$eof[[1]]$sdev %>% 
   DT(, let(correlation = 1, 
            angle = 0)) %>% 
   invisible()
```

```{r pad_longitudes}
grid <- ceof_era5[, eof[[1]]$right] %>% 
   unique(by = c("lon", "lat")) %>% 
   .[, .(lon, lat)] 

pad_longitudes <- function(data) {
   left <- right <- NULL
   rlon <- ggplot2::resolution(data$lon, zero = FALSE)
   mlon <- min(data$lon)
   Mlon <- max(data$lon)
   
   if (mlon > 0) {
      left <- data[lon == Mlon] %>% 
         DT(, lon := mlon - rlon)
   }   
   
   if (Mlon < 357.5) {
      right <- data[lon == mlon] %>% 
         DT(, lon := Mlon + rlon) 
   }
   
   rbind(left, 
         data, 
         right) 
}

interpolate_to_era <- function(data, formula = eof ~ lon + lat) {
   Interpolate(formula, x.out = unique(ref$lon), y.out = unique(ref$lat), 
               data = pad_longitudes(data)) 
}

```

```{r sst_era5}
sst_ear5 <- "DATA/reanalysis/ERA5/mon/era5sl.mon.mean.nc" %>% 
   ReadNetCDF(vars = c(sst = "sst"), 
              subset = list(
                 lat = c(-90, 10),
                 time = c("1979-01-01", "2014-12-31"))) %>% 
   DT(season(time) == "SON") %>% 
   DT(, .(sst = mean(sst)), by = .(lon, lat, time = year(time))) %>% 
   DT(, model := "ERA5") %>%
   DT(, ensemble := 1L) %>% 
   DT(is.finite(sst)) 
```


```{r rotate_eof}
weighted_correlation <- function(x, y, w) {
   cov.wt(cbind(x, y), wt = w, cor = TRUE)$cor[1, 2]
}

rotate <- function(z, angle = 0) {
   complex(real = cos(angle), imaginary = sin(angle)) * z
}

rotate_eof <- function(eof, angle) {
   eof <- copy(eof)
   eof$right <- eof$right[angle, on = "cEOF", ][, eof := rotate(eof, angle)][, angle := NULL]
   eof$left <- eof$left[angle, on = "cEOF", ][, eof := rotate(eof, angle)][, angle := NULL]
   eof
}
```

```{r rotation_era5}
enso <- rsoi::download_oni(use_cache = TRUE, file = "DATA/enso.csv") %>% 
   as.data.table() %>% 
   .[, .(time = lubridate::as_datetime(Date), oni = ONI)] %>% 
   na.omit() %>%
   .[season(time) == "SON"] %>%
   .[, .(oni = mean(oni)), by = .(time = year(time))]

with_enso <-  cut(ceof_era5$eof[[1]], 2)$left %>%
   copy() %>%
   enso[., on = "time"] %>% 
   na.omit() 

angles <- seq(-pi, pi, by = .5*pi/180)
rotations_cEOF2 <- lapply(angles, function(a) {
   with_enso %>%
      .[, hgt2 := rotate(eof, a)] %>%
      .[, .(R = cor(Re(hgt2), oni),
            I = cor(Im(hgt2), oni))] %>%
      .[, rotation := a]
}) %>%
   rbindlist()

best_rotation_cEOF2 <- rotations_cEOF2[I > 0][which.min(abs(R))]$rotation

ceof_era5$eof[[1]] <- rotate_eof(ceof_era5$eof[[1]],
                                 data.table(cEOF = c("cEOF1", "cEOF2"),
                                            angle = c(0, best_rotation_cEOF2)))


ceof_era5$eof[[1]]$left[, cEOF := factor(cEOF, levels = paste0("cEOF", 1:2),
                                         ordered = TRUE)]
ceof_era5$eof[[1]]$right[, cEOF :=  factor(cEOF, levels = paste0("cEOF", 1:2),
                                           ordered = TRUE)]
```

```{r optimise_rotation}

ref <- ceof_era5$eof[[1]]$right %>%
   copy() %>% 
   setnames("eof", "eof_ref")

optimise_rotation <- function(eof) {
   angles <- seq(-pi, pi, by = 0.5*pi/180)
   
   joined <- eof$right %>% 
      pad_longitudes() %>% 
      DT(, Interpolate(eof ~ lon + lat, x.out = unique(ref$lon), y.out = unique(ref$lat)), 
         by = .(cEOF, lev)) %>% 
      DT(ref, on = .NATURAL) %>% 
      na.omit()
   
   cors <- lapply(angles, function(a) {
      joined %>% 
         DT(, eof2 := rotate(eof, a)) %>% 
         DT(, .(correlation = weighted_correlation(Re(eof2), Re(eof_ref), cos(lat*pi/180))), 
            by = .(cEOF)) %>% 
         DT(, angle := a) 
   }) %>% 
      rbindlist()
   
   best_cor <- cors[, .SD[which.max(correlation)], by = cEOF]
   eof <- rotate_eof(eof, best_cor[, .(cEOF, angle)])
   
   eof$sdev <- eof$sdev[best_cor[, .(cEOF, correlation, angle)], on = "cEOF"]
   eof
}
```


```{r compute_eof}
compute_eof_ <- function(files, member, time = c("1979-10-01", "2014-12-31")) {
   message("procesando ", files[1])
   
   array <- lapply(files, function(file) {
      ReadNetCDF(file, vars = c(hgt = "zg"), 
                 subset = list(lat = c(-85, -20),
                               time = time),
                 out = "array")[[1]]
   })
   
   time_lookup <- data.table::data.table(time = dimnames(array[[1]])$time,
                                         time_date = as.integer(year(attr(array[[1]], "dimvalues")$time)))
   
   array <- abind::abind(array, rev.along = 0,
                         use.dnns = TRUE)
   
   dimnames(array)[[5]] <- member
   names(dimnames(array))[[5]] <- "ensemble"
   
   
   whichdim <- function(array, dims) {
      which((names(dimnames(array)) %in% dims))
   }
   whichdimnot <- function(array, dims) {
      which(!(names(dimnames(array)) %in% dims))
   }
   
   # Calcular anomalias zonales
   array <- apply(array, whichdimnot(array, "lon"), Anomaly) %>% 
      aperm(names(dimnames(array)))
   
   # Estandarizar
   sd <- apply(array, "plev", sd)
   array <- sweep(array, whichdim(array, "plev"), sd, FUN = "/")
   
   # Transfomar de hilbert
   hilbert <- apply(array, whichdimnot(array, "lon"), spectral::analyticFunction) %>% 
      aperm(names(dimnames(array)))
   
   hilbert <- aperm(hilbert, setNames(seq_along(dimnames(hilbert)), 
                                      names(dimnames(hilbert)))[c("time", "ensemble", "lon", "lat", "plev")])
   
   # Calcular EOF y hacer tidy
   dim(hilbert) <- list(prod(lengths(dimnames(hilbert))[1:2]),
                        prod(lengths(dimnames(hilbert))[3:5]))
   
   eof <- irlba::irlba(hilbert, 2, 2)
   
   dim(eof$u) <-  as.list(c(dimnames(array)[c("time", "ensemble")] %>% lengths(),
                            eof = 2))
   dimnames(eof$u) <- with(dimnames(array), 
                           list(time = time, ensemble = ensemble, cEOF = 1:2))
   eof$u <- reshape2::melt(eof$u, value.name = "eof") %>% data.table::setDT()
   eof$u[, time := as.character(time)]
   
   eof$u <- time_lookup[eof$u, on = .NATURAL] %>% 
      DT(, time := NULL) %>% 
      data.table::setnames("time_date", "time")
   eof$u[, cEOF := factor(paste0("cEOF", cEOF))]
   
   dim(eof$v) <- as.list(c(c(dimnames(array)[c("lon", "lat", "plev")] %>% lengths(),
                             eof = 2)))
   dimnames(eof$v) <- with(dimnames(array),
                           list(lon = lon, lat = lat, lev = plev, cEOF = 1:2))
   
   eof$v <- reshape2::melt(eof$v, value.name = "eof") %>%  data.table::setDT()
   eof$v[, cEOF := factor(paste0("cEOF", cEOF))]
   eof$v[, lat := as.numeric(lat)]
   eof$v[, lon := as.numeric(lon)]
   eof$v[, lev := as.integer(lev/100)]
   
   variance <- norm(abs(hilbert), type = "F")
   
   eof$d <- data.table(cEOF = factor(paste0("cEOF", 1:2), levels = paste0("cEOF", 1:2),
                                     ordered = TRUE), 
                       sd = eof$d, 
                       r2 = eof$d^2/variance^2)
   
   return(structure(
      list(left = eof$u, 
           right = eof$v, 
           sdev = eof$d),
      call = match.call(), 
      class = c("eof", "list"), 
      suffix = "cEOF", 
      value.var = "eof"))
}

compute_eof <- memoise::memoise(compute_eof_, cache = cache)
```


```{r ceofs} 
ceofs <- simulaciones %>% 
   .[variable == "zg"] %>%
   .[, .(eof = list(compute_eof(file, member) %>% optimise_rotation())), 
     by = model]
ceofs <- rbind(ceofs, ceof_era5)
# rm(ceof_era5)
```


```{r plot_ceof} 
plot_ceof <- function(data, n, which_lev = 200) {
   data <- data[, .(eof = list(cut(eof[[1]], n))), by = model]
   
   which_pc <- paste0("cEOF", n)
   
   models <- data %>% 
      DT(, eof[[1]]$sdev, by = model) %>%
      DT(cEOF == which_pc) %>% 
      DT(order(-correlation)) 
   
   labels <- models %>%
      DT(, setNames(paste0(model, "\n(", scales::number(correlation^2, 0.01), ")"),
                    model))
   
   data %>% 
      DT(, eof[[1]]$right, by = model) %>%
      # DT(, denormalise(eof[[1]], "right"), by = model) %>%
      DT(cEOF == which_pc) %>% 
      # DT(, eof[[1]]$right, by = model) %>%
      DT(, model := factor(model, levels = models$model)) %>%
      DT(lev == which_lev) %>% 
      DT(, eof := eof/max(Mod(eof)), by = model) %>% 
      DT(, interpolate_to_era(.SD), by = .(model, lev, cEOF)) %>% 
      # DT(, eof := eof/sd(eof), by = .(model)) %>% 
      ggperiodic::periodic(lon = c(0, 360)) %>% 
      ggplot(aes(lon, lat)) +
      geom_contour_fill(aes(z = Re(eof)), breaks = AnchorBreaks(exclude = 0)) +
      geom_contour2(aes(z = Im(eof), linetype = factor(-sign(..level..))), 
                    breaks = AnchorBreaks(exclude = 0)) +
      scale_linetype(guide = "none") +
      scale_fill_divergent(guide = "none") +
      geom_qmap(crop = c(ymax = -20)) +
      scale_x_longitude() +
      scale_y_latitude(limits = c(-90, NA)) +
      coord_polar() +
      facet_wrap(model ~., labeller = labeller(model = labels))
   
}
```



# Resultados

```{r interpolated}
interpolated <- ceofs[, eof[[1]]$right, by = model] %>% 
   copy() %>% 
   DT(model != "ERA5") %>% 
   DT(, interpolate_to_era(.SD),
      by = .(model, lev, cEOF)) %>% 
   DT(, eof_norm := eof/max(Mod(eof), na.rm = TRUE), by = .(cEOF, lev, model))


base <- ceof_era5[, eof[[1]]$right] %>% 
   copy() %>% 
   setnames("eof", "base") %>%
   setnames("plev", "lev") %>% 
   DT(, base := base/max(Mod(base)), by = .(cEOF, lev))

cor_mmm <- interpolated %>% 
   na.omit() %>% 
   DT(, mean(eof_norm), by = .(cEOF, lon, lat, lev)) %>% 
   DT(base, on = .NATURAL) %>% 
   DT(, weighted_correlation(Re(V1), Re(base), cos(lat*pi/180)), by = .(cEOF))
```

```{r cors}
cors <- ceofs %>% 
   DT(, eof[[1]]$sdev, by = model) %>% 
   # DT(model != "ERA5") %>% 
   copy() %>% 
   DT(, r2 := correlation^2) %>% 
   DT(, label := paste0(model, "\n(", scales::number(correlation^2, 0.01), ")"))
```

(ref:comparacion-r2-cap) $r^2$ de los patrones espaciales de cada modelo con ERA5 para cada cEOF.

```{r comparacion-r2, fig.height=6, fig.width=6}
cors %>% 
   DT(model != "ERA5") %>% 
   DT(, model := reorder(model, r2, fun = mean)) %>% 
   ggplot(aes(r2, model)) +
   geom_col(aes(fill = cEOF), position = "dodge") +
   scale_fill_brewer(palette = "Set1") +
   scale_x_continuous("R^2 espacial", limits = c(0, 1)) +
   scale_y_discrete(NULL)
```

La Figura\ \@ref(fig:comparacion-r2) muestra el $r^2$ de los modelos para los dos cEOFs. 
Por alguna razón los valores del superensemble tienen menos correlación que los miembros en promedio ¯\\\_(ツ)_/¯. 

## Parte espacial

Las Figuras\ \@ref(fig:ceofs-1-50) y \@ref(fig:ceofs-1-200) muestan el cEOF1 en 50 hPa y 200 hPa respectivamente. 
En general los patrones son bastante similares, especialmente en la estratósfera, donde e patrón es de mayor escala y entonces hay menos chances de cosas que fallen. 
Sin embargo, la localización de los centros no parece estar muy bien en algunos modelos. 
En 50 hPa IPSL-CM6A-LR, CNRM-CM6-1 y CNRM-ESM2-1 tienen la onda corrida hacia el oeste y un r^2 relativamente bajo.

```{r ceofs-1-50, fig.width=10, fig.height=13, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF1 en 50 hPa."}
plot_ceof(ceofs, 1, 50)
```

```{r ceofs-1-200, fig.width=10, fig.height=13, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF1 en 200 hPa."}
plot_ceof(ceofs, 1, 200)
```

En 200 hPa la cosa es un poco más compleja por los detalles de escala más chica, pero en general parece bien. 


En las Figuras\ \@ref(fig:ceofs-2-50)  y \@ref(fig:ceofs-2-200) se muestran lo mismo que antes pero para el cEOF2. 

```{r ceofs-2-50, fig.width=10, fig.height=13, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF2 en 50 hPa."}
plot_ceof(ceofs, 2, 50)
```

```{r ceofs-2-200, fig.width=10, fig.height=13, fig.fullwidth = TRUE, fig.cap = "Campos espaciales de cEOF2 en 200 hPa."}
plot_ceof(ceofs, 2, 200)
```


### Media multimodelo

Finalmente, la Figura \@ref(fig:mmm) muestra los patrones promedio multimodelo para cada cEOF y cada parte. 

(ref:mmm-cap) Media multimodelo (sombreado) de los campos espaciales de cada cEOF, parte y nivel. Los contornos marcan los patrones de ERA5. El $r^2$ entre ERA5 y la media multimodelo está entre paréntesis.

```{r mmm, fig.width=10}
ceof_labs <- cor_mmm %>% 
   DT(, paste0(cEOF, "\n(", scales::percent(V1^2, 0.1), ")") %>% 
         setNames(cEOF)
   )

interpolated %>% 
   DT(, mean(eof_norm), by = .(cEOF, lon, lat, lev)) %>% 
   sep_ReIm() %>% 
   periodic_lon() %>% 
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = V1), breaks = AnchorBreaks(exclude = 0)) +
   geom_contour2(aes(z = base, linetype = factor(-sign(..level..))),
                 data = sep_ReIm(base) %>% periodic_lon(),
                 breaks = AnchorBreaks(exclude = 0)) +
   scale_linetype(guide = "none") +
   scale_fill_divergent(guide = "none") +
   geom_qmap(crop = c(ymax = -20)) +
   scale_x_longitude() +
   scale_y_latitude(limits = c(-90, NA)) +
   coord_polar() +
   ggh4x::facet_nested(lev ~ cEOF + part, labeller = labeller(lev = AddSuffix(" hPa"),
                                                              cEOF = ceof_labs))
```

El patrón medio multimodelo es increíblemente similar al patrón de ERA5, con niveles de $r^2$ del orden del 90%. 

En base a esto y a la metodología usada en la literatura, propongo que un próximo paso para evaluación de atribución o tendencias futuras use este patrón promedio para obtener las series temporales en vez de los propios de cada modelo. 

## Parte temporal

Para analizar las propiedades de los modos de cada modelo uso las series temporales propias de cada modelo. 

```{r plot_trends, fig.height = 12, fig.width=8}
plot_trends <- function(which_eof) {
   which_eof <- paste0("cEOF", which_eof)
   models <- cors[cEOF == which_eof] %>% 
      .[order(correlation)] %>% 
      .[, model]
   
   ceofs[, eof[[1]]$left, by = model] %>% 
      .[cEOF == which_eof] %>%
      copy() %>% 
      .[, eof := eof/sd(Mod(eof)), by = .(model)] %>% 
      sep_ReIm() %>% 
      .[, FitLm(eof, time = time/10, se = TRUE), 
        by = .(model, cEOF, ensemble, part)] %>% 
      .[term == "time"] %>%
      cors[., on = c("model", "cEOF")] %>% 
      .[, model := paste0(model, "\n(", scales::number(correlation^2, 0.01), ")")] %>% 
      .[, model := reorder(model, correlation)] %>% 
      ggplot(aes(model, estimate)) +
      geom_hline(yintercept = 0, color = "gray50") +
      geom_tile(data = ~.x[, .(m = 2*mean(std.error)), by = .(model, part)],
                aes(y = 0,
                    height = 2*m,
                    width = 0.5,
                    group = part),
                alpha = 0.2,
                position = position_dodge(.8)) +
      geom_point(alpha = 0) +
      geom_boxplot(aes(color = part), width = 0.5,
                   position = position_dodge(.8),
                   fill = NA,
                   data = ~.x[!startsWith(as.character(model), "ERA5")]) +
      ggforce::geom_sina(aes(color = part), alpha = 0.5) +
      scale_color_brewer(palette = "Set1") +
      coord_flip()  
}
```

Las Figuras\ \@ref(fig:trends-1) y \@ref(fig:trends-1) muestran las tendencias lineales de cada cEOF. 
El recurado gris marca la región aproximada de insignificancia estadística al 5% ($\pm$ 2 errores estándar) y la conclusión es que no hay tendencias significativas. 

(ref:trends-1-cap) Tendencias durante todo el período (en desvios estándared por década) para la parte real e imaginaria del cEOF1 de cada miembro de cada modelo. El área gris marca la región aproximada de insignificancia estadística usando $\pm$ 2 errores estándares, tomando el error estándar promedio de las estimaciones de cada modelo. 

```{r trends-1, fig.height = 12, fig.width=8}
plot_trends(1)
```

(ref:trends-2-cap) Igual que la Figura \@ref(fig:trends-1) pero para el cEOF2.

```{r trends-2, fig.height = 12, fig.width=8}
plot_trends(2)
```


```{r fft}
fft <- ceofs[, eof[[1]]$left, by = model] %>% 
   sep_ReIm() %>% 
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>%
   .[order(time)] %>% 
   .[, fftspectrum(eof, c(3, 5), B = 0), by = .(model, ensemble, cEOF, part)]
```

```{r alpha_from_n}
alpha_from_n <- function(n, max_alpha = 0.99) {
   1 - (1 - max_alpha)^(1/n)
}
```

```{r plot_fft} 
plot_fft <- function(which_ceof) {
   which_ceof <- paste0("cEOF", which_ceof)
   
   labs <- cors[cEOF == which_ceof] %>% 
      .[, setNames(label, model)]
   
   
   fft %>% 
      .[cEOF == which_ceof] %>% 
      # .[, .(spec = mean(spec)), by = .(freq, part, model, cEOF)] %>% 
      cors[., on = c("model", "cEOF")] %>% 
      .[, model := reorder(model, -correlation)] %>% 
      .[, ensembleN := uniqueN(ensemble), by = model] %>% 
      ggplot(aes(1/freq, spec)) +
      # geom_ribbon(aes(ymin = 0, ymax = `95%`), position = "dodge", alpha = 0.1) +
      # geom_line(aes(y = ar_spectrum), alpha = 0.15) +
      geom_line(aes(color = part, group = interaction(part, ensemble),
                    alpha = alpha_from_n(ensembleN, 0.9))) +
      geom_line(data = ~.x[, .(spec = mean(spec)), by = .(freq, part, model, cEOF)],
                aes(color = part)) +
      # annotation_logticks(sides = "b") +
      scale_color_brewer(which_ceof, palette = "Set1", aesthetics = c("color", "fill")) +
      scale_x_log10("Period (years)") +
      scale_y_continuous("Spectrum")  +
      scale_alpha_identity() +
      facet_wrap(model ~ ., labeller = labeller(model = labs))
}
```

Las Figuras\ \@ref(fig:fft-1) y \@ref(fig:fft-2) muestran periodogramas para cada cEOF con una línea por miembro y una línea gruesa marcando el periodograma promedio.

(ref:fft-1-cap) Espectros de Fourier para la parte Real e Imaginaria del cEOF1. En línea obscura es el espectro promedio de todos los miembros, que se muestran en líneas translúcidas.

```{r fft-1, fig.height=10, fig.width=10}
plot_fft(1)
```

Para el cEOF1, no hay mucha señal. Algunos miembros tienen señales altas pero en el promedio es básicamente chato, coincidente con ERA5.

(ref:fft-2-cap) Igual que Figura \@ref(fig:fft-1) pero para el cEOF2. En recuadro negro, modelos que tienen un período importante cerca de 3 años en la parte imaginaria del cEOF2.

```{r fft-2, fig.height=10, fig.width=10}
con_picos <- data.table(
   model = c("FGOALS-g3", "MIROC6", "GISS-E2-1-G", "CESM2", "CNRM-ESM2-1", "CNRM-CM6-1")
)


plot_fft(2) +
   geom_rect(data = ~.x[con_picos, on = "model"] %>% 
                .[, model := reorder(model, -correlation)],
             inherit.aes = FALSE,
             xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
             fill = NA, color = "#7e8087") 
```

Para el cEOF2, algunos modelos tiene una señal consistente de ~3 años en la parte imaginaria, también consistente con ERA5. 
Sin embargo, la señal no aparece en todos los modelos. 

Dada la relación entre ENSO y el cEOF2 se puede ver si los modelos que tienen la periodicidad clara de 3 años también tienen esa periodicidad en el ENSO. 

La Figura \@ref(fig:ensofft) Muestra los periodogramas del el índice de ENSO34 de cada modelo y miembro. 
Se ve que, en efecto, los modelos seleccionados antes tienen un período en el ENSO más claro que el resto. 

```{r enso_cmip}

compute_enso <- function(file) {
   ReadNetCDF(file, vars = c(sst = "tos"), 
              subset = list(lat = c(-5, 5),
                            time = c("1979-09-01", "2014-12-31"),
                            lon = ConvertLongitude(c(-170, -120)))) %>% 
      .[!is.na(sst)] %>% 
      .[, time := year(time)] %>% 
      .[, .(enso34 = mean(sst)), by = .(time)] %>% 
      .[, enso34 := (enso34 - mean(enso34))/sd(enso34)] %>% 
      .[]
}

enso_cmip <- simulaciones %>% 
   .[variable == "tos"] %>%
   .[, compute_enso(file), by = .(model, member)] 

enso_cmip <- enso %>% 
   copy() %>% 
   .[, `:=`(model = "ERA5", member = 1)] %>% 
   setnames("oni", "enso34") %>% 
   rbind(enso_cmip)


```

(ref:ensofft-cap) Espectros de Fourier para los índices ENSO34 de cada modelo. En línea obscura es el espectro promedio de todos los miembros, que se muestran en líneas translúcidas. En recuadro negro, los mismos modelos recuadrados en la Figura \@ref(fig:fft-2). 

```{r ensofft, fig.height=8, fig.width=9}

labs <- cors[cEOF == "cEOF2"] %>% 
   .[, setNames(label, model)]

enso_cmip %>% 
   .[order(time)] %>% 
   .[, fftspectrum(enso34, c(3, 5), B = 0), by = .(model, member)] %>% 
   .[cors[cEOF == "cEOF2"], on = c("model")] %>% 
   .[, model := reorder(model, -correlation)] %>% 
   .[, ensembleN := uniqueN(member), by = model] %>% 
   ggplot(aes(1/freq, spec)) +
   geom_line(aes(group = member, alpha = alpha_from_n(ensembleN, 0.9))) +
   geom_line(data = ~.x[, .(spec = mean(spec)), by = .(freq, model)]) +
   # annotation_logticks(sides = "b") +
   scale_x_log10("Period (years)") +
   scale_y_continuous("Spectrum")  +
   scale_alpha_identity() +
   facet_wrap(model ~ ., labeller = labeller(model = labs)) +
   geom_rect(data = ~.x[con_picos, on = "model"] %>% 
                .[, model := reorder(model, -correlation)],
             inherit.aes = FALSE,
             xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,
             fill = NA, color = "#7e8087") 
```


## SST

Finalmente, queremos evaluar si los modelos capturan correctamente la relación entre los modos y las anomalías de temperatura de la superficie del mar. 

```{r regress_sst}
standardised <- ceofs[, eof[[1]]$left, by = model] %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, ensemble, cEOF)] 

regress_sst_ <- function(..model) {
   sst_files <- simulaciones %>% 
      .[variable == "tos"] %>% 
      .[model == ..model]
   
   message("Procesando: ", sst_files$file[1])
   
   data <- lapply(seq_len(nrow(sst_files)), function(i) {
      ReadNetCDF(sst_files[i, ]$file, c(sst = "tos"), 
                 subset = list(lat  = c(-90, 10), 
                               time = c("1979-10-01", "2014-12-31"))) %>% 
         .[!is.na(sst)] %>% 
         .[, time := year(time)] %>% 
         .[, ensemble := as.integer(sst_files[i, ]$member)] 
   })
   
   data <- rbindlist(data)
   
   enso34 <- data %>% 
      .[is.enso34(lon, lat)] %>% 
      .[, .(enso34 = mean(sst)), by = .(time, ensemble)] %>% 
      .[, enso34 := (enso34 - mean(enso34))/sd(enso34), by = .(ensemble)]
   
   s <- standardised %>% 
      .[model == ..model] %>% 
      .[ensemble %in% unique(data$ensemble)] %>% 
      .[cEOF == "cEOF2"] %>% 
      enso34[., on = c("time", "ensemble")] 
   
   
   angles <- seq(-pi, pi, by = .5*pi/180)
   rotations_cEOF2 <- lapply(angles, function(a) {
      s %>%
         .[, hgt2 := rotate(eof, a)] %>%
         .[, .(R = cor(Re(hgt2), enso34),
               I = cor(Im(hgt2), enso34))] %>%
         .[, rotation := a]
   }) %>%
      rbindlist()
   
   best_rotation_cEOF2 <- rotations_cEOF2[I > 0][which.min(abs(R))]$rotation
   
   regression <- standardised %>% 
      .[model == ..model] %>% 
      .[ensemble %in% unique(data$ensemble)] %>%
      # best_rotation_cEOF2[., on = "ensemble"] %>% 
      .[cEOF == "cEOF2", eof := rotate(eof, best_rotation_cEOF2)] %>% 
      sep_ReIm(format = "wider") %>% 
      data[., on = c("time", "ensemble"), allow.cartesian = TRUE] %>% 
      .[, FitLm(sst, Real, Imaginary, se = TRUE), 
        by = .(lon, lat,  cEOF, model)] %>% 
      .[term != "(Intercept)"] %>% 
      .[, model := NULL]
   
   return(regression)
}


regress_sst <- memoise::memoise(regress_sst_, cache = cache)
```



```{r sst_regression}
sst_regression <- simulaciones %>% 
   # .[model %in% "IPSL-CM6A-LR"] %>%
   .[, regress_sst(model[1]), by = .(model)]
```


```{r plot_sst_regression}
plot_sst_regression <- function(which_ceof) {
   which_ceof <- paste0("cEOF", which_ceof)
   sst_regression %>% 
      .[cEOF == which_ceof] %>% 
      copy() %>% 
      .[!is.na(estimate)] %>% 
      .[, p.val := Pvaluate(estimate, std.error, df, "fdr"), by = .(cEOF, term, model)] %>%
      .[, estimate := estimate/sd(estimate), by = .(model)] %>%
      .[, enso := mean(estimate[is.enso34(lon, lat) & term == "Imaginary"]), 
        by = .(cEOF, model)] %>%
      .[, model := reorder(model, -enso)] %>%
      # .[model == "CESM2"] %>%
      ggplot(aes(lon, lat)) +
      geom_contour_fill(aes(z = estimate), breaks = AnchorBreaks(binwidth = 0.5, exclude = 0)) +
      geom_contour2(aes(z = p.val), breaks = 0.5,
                    size = 0.3) +
      stat_subset(aes(subset = is.cross(lon, lat, 1) & p.val <= 0.05),
                  alpha = 0.2, size = 0.3) +
      scale_fill_divergent(guide = "none") +
      ggnewscale::new_scale_fill() +
      geom_contour_fill(data = height, aes(z  = h), fill = "gray90",
                        breaks = c(0, max(height$h))) +
      geom_contour2(data = height, aes(z  = h),
                    size = 0.2, breaks = 0) +
      scale_y_latitude() +
      scale_x_longitude() +
      facet_grid(model ~ term) +
      coord_quickmap()
}
```

(ref:sst-1-cap) Regresión de cEOF1 con la SST para la parte real e imaginaria. 

La Figura \@ref(fig:sst-1) muetra la regresión para el cEOF1. 
Todos los modelos tienne valores de regresión altos y significativos en casi todo el globo. 
Esto no es consistente con lo observado en ERA5, en donde no hay relación entre el cEOF1 y las SSTs. 

```{r sst-1, fig.height=20, fig.width=7}
plot_sst_regression(1)
```

(ref:sst-2-cap) Igual que Figura \@ref(fig:sst-1) pero para el cEOF2.

```{r sst-2, fig.height=20, fig.width=7}
plot_sst_regression(2)
```

La Figura \@ref(fig:sst-2) muestra lo mismo para el cEOF2. 
Este modo también muestra regresiones signifiativas en todo el globo. 
El patrón en la región ENSO es más o menos consistente con ERA5: relación positva con la parte imaginaria y casi ceo con la real. 
Sin embargo, en este modo también las relaciones significativas son mucho mayores que en ERA5. 

La Figura \@ref(fig:sst-mmm) muestra el promedio multimodelo de estas regresiones.  

(ref:sst-mmm-cap) Promedio multimodelo de las regresiones de las figuras \@ref(fig:sst-1) y \@ref(fig:sst-2). 

```{r sst-mmm, fig.width=9, fig.height=4}
sst_regression %>% 
   copy() %>% 
   .[, estimate := estimate/sd(estimate), by = .(model, cEOF)] %>%
   .[, .(estimate = mean(estimate)), by = .(term, lon, lat, cEOF)] %>% 
   ggplot(aes(lon, lat)) +
   geom_contour_fill(aes(z = estimate), breaks = AnchorBreaks(binwidth = 0.5, exclude = 0)) +
   
   scale_fill_divergent(guide = "none") +
   ggnewscale::new_scale_fill() +
   geom_contour_fill(data = height, aes(z  = h), fill = "gray90",
                     breaks = c(0, max(height$h))) +
   geom_contour2(data = height, aes(z  = h),
                 size = 0.2, breaks = 0) +
   scale_y_latitude() +
   scale_x_longitude() +
   facet_grid(cEOF ~ term) +
   coord_quickmap()
```


```{r download-enso_perf}
enso_perf_file <- "DATA/enso_perf.csv"

if (!file.exists(enso_perf_file)) {
   file <- tempfile()
   url <- "https://pcmdi.llnl.gov/pmp-preliminary-results/interactive_plot/portrait_plot/enso_metric/raw_values/ENSO_perf_normalizedValue_v20210723_v20201122.xlsx"
   
   download.file(url, file, mode = "wb")
   data <- readxl::read_excel(file)   
   colnames(data)[1] <- "model" 
   setDT(data)
   data <- data[startsWith(model, "*")]
   data[, model := gsub("\\* ", "", model)]
   data <- data[!startsWith(model, "(")]
   data <- melt(data, id.var = "model", variable.name = "metric")
   fwrite(data, enso_perf_file)
}

enso_teleconnections_file <- "DATA/enso_teleconnections.csv"

if (!file.exists(enso_teleconnections_file)) {
   file <- tempfile()
   url <- "https://pcmdi.llnl.gov/pmp-preliminary-results/interactive_plot/portrait_plot/enso_metric/raw_values/ENSO_tel_normalizedValue_v20210723_v20201122.xlsx"
   
   download.file(url, file, mode = "wb")
   data <- readxl::read_excel(file)   
   colnames(data)[1] <- "model" 
   setDT(data)
   data <- data[startsWith(model, "*")]
   data[, model := gsub("\\* ", "", model)]
   data <- data[!startsWith(model, "(")]
   data <- melt(data, id.var = "model", variable.name = "metric")
   fwrite(data, enso_teleconnections_file)
}

enso_perf <- fread(enso_perf_file)
enso_teleconnections <- fread(enso_teleconnections_file)
```


(ref:enso-perf-plot-cap) Relación entre la correlación espacial de cada cEOF de cada modelo con ERA5 y valores normalizados de las métricas de performance de ENSO según [Planton et al. 2021](https://pcmdi.llnl.gov/pmp-preliminary-results/interactive_plot/portrait_plot/enso_metric/enso_metrics_interactive_portrait_plots_v20210723.html).

```{r enso-perf-plot, fig.height=12, fig.width = 6}
ceofs[, eof[[1]]$sdev, by = model] %>% 
   .[model != "ERA5"] %>% 
   enso_perf[., on = "model"] %>% 
   .[, picos := model %in% con_picos$model] %>% 
   .[!is.na(metric)] %>% 
   ggplot(aes(correlation, value)) +
   geom_point(aes(color = picos)) +
   geom_smooth(method = "lm") +
   scale_y_continuous(NULL) +
   facet_grid(metric ~ cEOF, scales = "free") +
   theme(strip.text.y = element_text(angle = 0, size = rel(0.8)), 
         panel.background = element_rect(fill = "#f1f1f1", 
                                         color = "#f1f1f1"), 
         panel.ontop = FALSE) 
```

(ref:enso-teleconnections-plot-cap) Igual que la Figura \@ref(fig:enso-perf-plot) pero para las métricas de teleconexiones de ENSO. 

```{r enso-teleconnections-plot, fig.height=12, fig.width = 6}
ceofs[, eof[[1]]$sdev, by = model] %>% 
   .[model != "ERA5"] %>% 
   enso_teleconnections[., on = "model"] %>% 
   .[, picos := model %in% con_picos$model] %>% 
   .[!is.na(metric)] %>% 
   ggplot(aes(correlation, value)) +
   geom_point(aes(color = picos)) +
   geom_smooth(method = "lm") +
   scale_y_continuous(NULL) +
   facet_grid(metric ~ cEOF, scales = "free") +
   theme(strip.text.y = element_text(angle = 0, size = rel(0.8)), 
         panel.background = element_rect(fill = "#f1f1f1", 
                                         color = "#f1f1f1"), 
         panel.ontop = FALSE) 
```

# Serie temporal larga 

Hay dos formas de extender los cEOFS para odo el período, puedo recomputar el cEOF usando todos los datos, o puedo proyectar los campos obtenidos. 
La primera es más natural, pero tiene el inconveniente de que la interpretación depende de que los cEOFs obtenidos seaon comparables (los campos sean iguales o similares). 

```{r ceofs_larga }
ceofs_larga <- simulaciones %>% 
   .[variable == "zg"] %>%
   .[, .(eof = list(compute_eof(file, member, time = c(NA, "2014-12-31")) %>%
                       optimise_rotation())), 
     by = model]
```

```{r eof_proyectado}
fields <- ceofs[, eof[[1]]$right, by = model] %>% 
   sep_ReIm()

setorder(fields, model, part, cEOF, -lev, lat, lon)
# a <- simulaciones %>% 
#         .[variable == "zg"] %>% .[model == unique(model)[3]]
# files <- a$file
# member <- a$member
# model <- a$model

eof_proyectado_ <- function(files, member, ..model, time = c(NA, "2014-12-31")) {
   message("procesando ", files[1])
   
   array <- lapply(files, function(file) {
      ReadNetCDF(file, vars = c(hgt = "zg"), 
                 subset = list(lat = c(-85, -20),
                               time = time),
                 out = "array")[[1]]
   })
   
   time_lookup <- data.table::data.table(time = dimnames(array[[1]])$time,
                                         time_date = as.integer(year(attr(array[[1]], "dimvalues")$time)))
   
   array <- abind::abind(array, rev.along = 0,
                         use.dnns = TRUE)
   
   dimnames(array)[[5]] <- member
   names(dimnames(array))[[5]] <- "ensemble"
   
   
   whichdim <- function(array, dims) {
      which((names(dimnames(array)) %in% dims))
   }
   whichdimnot <- function(array, dims) {
      which(!(names(dimnames(array)) %in% dims))
   }
   
   # Calcular anomalias zonales
   array <- apply(array, whichdimnot(array, "lon"), Anomaly) %>% 
      aperm(names(dimnames(array)))
   
   # Estandarizar
   sd <- apply(array, "plev", sd)
   array <- sweep(array, whichdim(array, "plev"), sd, FUN = "/")
   
   f <- fields[model == ..model[1]]
   fa <- array(f$eof, dim = c(lon = uniqueN(f$lon), 
                              lat = uniqueN(f$lat), 
                              lev = uniqueN(f$lev),
                              cEOF = uniqueN(f$cEOF),
                              part = uniqueN(f$part)),
               dimnames = list(lon = unique(f$lon),
                               lat = unique(f$lat),
                               lev = unique(f$lev)*100,
                               cEOF = unique(f$cEOF),
                               part = unique(f$part))
   )
   
   v <- apply(array, c("time", "ensemble") , function(a) {
      # ESTO NO DEBERÍA SER TAN COMPLICADO!!!
      v <- apply(fa, c("cEOF"), function(f) {
         r <- .lm.fit(cbind(c(f[, , , 1]), c(f[, , , 2])), c(a))
         exp <- 1 - var(r$residuals)/var(c(a))
         setNames(c(r$coefficients, exp), c(dimnames(f)[["part"]], "r2"))
      }) 
      
      names(dimnames(v))[1] <- "variable"
      v <- reshape::melt(v)
      names <- paste(v$variable, v$cEOF, sep = ".")
      setNames(v$value, names)
   })
   
   names(dimnames(v))[1] <- "variable.cEOF"
   
   reshape2::melt(v, value.name = "eof") %>% 
      setDT() %>% 
      .[, c("variable", "cEOF") := tstrsplit(variable.cEOF,
                                             split = ".", fixed = TRUE)] %>% 
      .[, variable.cEOF := NULL] %>% 
      dcast(time + ensemble + cEOF ~ variable, value.var = "eof") %>% 
      .[, eof := complex(real = Real, imaginary = Imaginary)] %>% 
      .[, `:=`(Imaginary = NULL, Real = NULL)] %>% 
      .[, time := as.character(time)] %>% 
      time_lookup[., on = "time"] %>% 
      .[, time := NULL] %>% 
      setnames("time_date", "time") %>% 
      .[]
}

eof_proyectado <- memoise::memoise(eof_proyectado_, cache = cache)
```

```{r ceof_largo_p}
ceof_largo_p <- simulaciones %>% 
   .[variable == "zg"] %>% 
   .[, eof_proyectado(file, member, model), by = model] 
```

(ref:correlacion-metodos-cap) Correlación entre las series temporales de cada modelo, miembro, cEOF y parte calculadas como los cEOF de toda la serie o proyectando los campos obtenidos con el período moderno. 

```{r correlacion-metodos, fig.height=5, fig.width=6}
ceofs_larga[, eof[[1]]$left, by = model] %>% 
   copy() %>% 
   .[, r2 := NA] %>% 
   rbind(eof = ., 
         proyectado = ceof_largo_p, idcol = "metodo") %>% 
   sep_ReIm() %>% 
   copy() %>% 
   dcast(model + time + ensemble + cEOF + part ~ metodo, value.var = "eof") %>% 
   .[, cor(proyectado, eof), by = .(model, cEOF, part)] %>% 
   ggplot(aes(model, V1)) +
   geom_point(position = position_jitter(width = 0.2, height = 0)) +
   scale_y_continuous("Correlacion", limits = c(0, 1)) +
   scale_x_discrete(NULL) +
   coord_flip()
```

Por suerte, no hace falta elegir ya que ambos métodos dan prácticamente el mismo resultado, como se ve en la Figura \@ref(fig:correlacion-metodos).

Por las ventajas de interpretación y demás, vamos a seguir con la proyección.

## Series

(ref:tendencia-cap) Series temporales de anomalías estandarizadas de los cEOFs computados usando el período `r paste0(range(ceofs_larga[1, eof[[1]]$left]$time), collapse = " -- ")`. Las anomalías están computadas sobre el período 1850 -- 1900. En líneas translúcidas, las series promedio de cada modelo. En línea oscura, la media multimodelo. La línea azul es un loess smooth de la media multimodelo. 

```{r tendencia, fig.width=6, fig.height=4}
ceof_largo_p %>% 
   sep_ReIm() %>% 
   .[, eof := scale(eof, center = mean(eof[time <= 1900]), 
                    scale = sd(eof[time <= 1900])),
     by = .(model, part, cEOF)] %>% 
   .[, .(eof = mean(eof)), by = .(model, time, cEOF, part)] %>% 
   ggplot(aes(time, eof)) +
   geom_line(aes(group = model), alpha = 0.1) +
   geom_line(data = ~.x[, .(eof = mean(eof)), by = .(time, cEOF, part)]) +
   geom_smooth(data = ~.x[, .(eof = mean(eof)), by = .(time, part, cEOF)]) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   coord_cartesian(ylim = c(-1.5, 1.5)) +
   facet_grid(part ~ cEOF)
```

La Figura \@ref(fig:tendencia) muestra las series temporales de los cEOfs. 
Se ve que la parte real del cEOF1 tiene una tendencia a la alza bien clara.
Las otras series no tienen tendencias. 

El cEOF2 real tiene una pequeña tendencia que se ve en la media multimodelo. 
(ref:tendencias-largas-cap) Igual que la Figura \@ref(fig:trends-1) pero para el período 1950 -- 2014. 

```{r tendencias-largas, fig.height = 12, fig.width=8}
ceof_largo_p %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>% 
   .[time >= 1950] %>% 
   sep_ReIm() %>% 
   .[, FitLm(eof, time = time/10, se = TRUE), 
     by = .(model, cEOF, ensemble, part)] %>% 
   .[term == "time"] %>%
   # cors[., on = c("model", "cEOF")] %>% 
   # .[, model := paste0(model, "\n(", scales::number(correlation^2, 0.01), ")")] %>% 
   # .[, model := reorder(model, correlation)] %>% 
   ggplot(aes(model, estimate)) +
   geom_hline(yintercept = 0, color = "gray50") +
   geom_tile(data = ~.x[, .(m = 2*mean(std.error)), by = .(model, part)],
             aes(y = 0,
                 height = 2*m,
                 width = 0.5,
                 group = part),
             alpha = 0.2,
             position = position_dodge(.8)) +
   geom_point(alpha = 0) +
   geom_boxplot(aes(color = part), width = 0.5,
                position = position_dodge(.8),
                fill = NA,
                data = ~.x[!startsWith(as.character(model), "ERA5")]) +
   ggforce::geom_sina(aes(color = part), alpha = 0.5) +
   scale_x_discrete(NULL) +
   scale_color_brewer(palette = "Set1") +
   coord_flip()  +
   facet_wrap(cEOF~ ., scale = "free_x")
```

La Figura \@ref(fig:tendencias-largas) reproduce las Figuras \@ref(fig:trends-1) y \@ref(fig:trends-2) para el período empezando en 1950. 


(ref:tendencias-roll-cap) Tendencias estandarizadas (con el período 1850 -- 1900 como base) estimadas en ventanas de 20 años. En líneas translúcidas las tendencias calculadas con el cEOF medio de cada modelo y en línea negra la tendencia de la media multimodelo. 


```{r tendencias-roll, fig.height=5, fig.width=7}
ceof_largo_p %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>% 
   sep_ReIm() %>% 
   .[, .(eof = mean(eof)), by = .(model, time, part, cEOF)] %>%
   rbind(., 
         .[, .(eof = mean(eof), model = "MMM"), by = .(time, part, cEOF)]) %>% 
   .[order(time)] %>% 
   .[, trend := roll::roll_lm(time, eof, width = 20)$coefficients[, 2],
     by = .(cEOF, part, model)] %>% 
   .[!is.na(trend)] %>% 
   ggplot(aes(time, trend)) +
   geom_hline(yintercept = 0, size = 0.1) +
   geom_line(aes(group = model, alpha = model == "MMM")) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   scale_alpha_manual(NULL, values = c("TRUE" = 1, "FALSE" = 0.1), 
                      guide = "none") +
   facet_grid(part ~ cEOF)
```

La Figura \@ref(fig:tendencias-roll) muetra las tendencias de la media de cada modelo calculada en ventanas de 20 años. 
Se obseva la tendencia positiva de la parte real del cEOF1 que compienza al rededor de 1980. 
Por otro lado, también se ve que la parte real del cEOF2 tiene una pequeña tendencia. 


(ref:varianza-roll-cap) 

```{r varianza-roll,  fig.height=5, fig.width=7}
ceof_largo_p %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof[time < 1900])), by = .(model, cEOF)] %>% 
   sep_ReIm() %>%
   .[order(time)] %>% 
   .[, var := roll::roll_var(eof, width = 20),
     by = .(cEOF, part, model, ensemble)] %>%
   .[!is.na(var)] %>%
   .[, .(var = mean(var)), by = .(model, time, cEOF, part)] %>% 
   ggplot(aes(time, var)) +
   # geom_hline(yintercept = 0, size = 0.1) +
   geom_line(aes(group = model), alpha = 0.1) +
   geom_line(data = ~.x[, .(var = mean(var)), by = .(time, cEOF, part)]) +
   geom_smooth(data = ~.x[, .(var = mean(var)), by = .(time, part, cEOF)]) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   facet_grid(part ~ cEOF)
```


```{r}
ceof_largo_p %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>% 
   .[order(time)] %>% 
   .[, var := roll::roll_var(Mod(eof), width = 20),
     by = .(cEOF, model, ensemble)] %>%
   .[!is.na(var)] %>%
   .[, .(var = mean(var)), by = .(model, time, cEOF)] %>% 
   ggplot(aes(time, var)) +
   # geom_hline(yintercept = 0, size = 0.1) +
   geom_line(aes(group = model), alpha = 0.1) +
   geom_line(data = ~.x[, .(var = mean(var)), by = .(time, cEOF)]) +
   geom_smooth(data = ~.x[, .(var = mean(var)), by = .(time, cEOF)]) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   facet_grid(. ~ cEOF)
```


(ref:tendencia-mod-cap) Amplitud promedio de cada modo en cada modelo (líneas translúcidas) y la amplitud media multimodelo (línea negra) y loess smooth de la media multimodelo (línea azul).

```{r tendencia-mod, fig.height=4, fig.width=7}
i <- complex(imaginary = 1)
ceof_largo_p %>% 
   copy() %>% 
   .[, eof := eof/sd(Mod(eof[time <= 1900])), by = .(model, cEOF)] %>% 
   sep_ReIm() %>% 
   tidyfast::dt_pivot_wider(names_from = part, values_from = eof) %>% 
   .[, ceof := Real + Imaginary*i] %>% 
   .[, ceof := Anomaly(ceof, time <= 1900), by = .(model, cEOF)] %>% 
   .[, .(eof = mean(Mod(ceof))), by = .(model, time, cEOF)] %>% 
   ggplot(aes(time, eof)) +
   geom_line(aes(group = model), alpha = 0.1) +
   geom_line(data = ~.x[, .(eof = mean(eof)), by = .(time, cEOF)]) +
   geom_smooth(data = ~.x[, .(eof = mean(eof)), by = .(time, cEOF)]) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   facet_grid(. ~ cEOF)
```

La tendencia del cEOF1 Real se destaca en el cambio en la amplitud del cEOF1. 
La amplitud del cEOF2 también aumentó ligeramente. 

```{r}
ceof_largo_p %>%
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>% 
   .[time >= 1950] %>% 
   .[, FitLm(Mod(eof), time = time/10, se = TRUE), 
     by = .(model, cEOF, ensemble)] %>% 
   .[term == "time"] %>%
   # cors[., on = c("model", "cEOF")] %>% 
   # .[, model := paste0(model, "\n(", scales::number(correlation^2, 0.01), ")")] %>% 
   # .[, model := reorder(model, correlation)] %>% 
   ggplot(aes(model, estimate)) +
   geom_hline(yintercept = 0, color = "gray50") +
   geom_tile(data = ~.x[, .(m = 2*mean(std.error)), by = .(model)],
             aes(y = 0,
                 height = 2*m,
                 width = 0.5),
             alpha = 0.2,
             position = position_dodge(.8)) +
   geom_point(alpha = 0) +
   geom_boxplot(width = 0.5,
                position = position_dodge(.8),
                fill = NA,
                data = ~.x[!startsWith(as.character(model), "ERA5")]) +
   ggforce::geom_sina(alpha = 0.5) +
   scale_x_discrete(NULL) +
   scale_color_brewer(palette = "Set1") +
   coord_flip()  +
   facet_wrap(cEOF~ ., scale = "free_x")
```


(ref:tendencia-r2-cap) Varianza explicada por cada modo en cada modelo (líneas translúcidas) y la varianza explicada media multimodelo (línea negra) y loess smooth de la media multimodelo (línea azul).

```{r tendencia-r2, fig.height=4, fig.width=7}
ceof_largo_p %>% 
   .[, .(r2 = mean(r2)), by = .(model, time, cEOF)] %>% 
   ggplot(aes(time, r2)) +
   geom_line(aes(group = model), alpha = 0.1) +
   geom_line(data = ~.x[, .(r2 = mean(r2)), by = .(time, cEOF)]) +
   geom_smooth(data = ~.x[, .(r2 = mean(r2)), by = .(time, cEOF)]) +
   scale_x_continuous(NULL) +
   scale_y_continuous(NULL) +
   # coord_cartesian(ylim = c(0, 1)) +
   facet_wrap(. ~ cEOF, scales = "free_y")
```


```{r}
ceof_largo_p %>% 
   .[, cor(r2, Mod(eof)), by = .(cEOF, model, ensemble)] %>% 
   tidyfast::dt_pivot_wider(names_from = cEOF, values_from = V1) %>% 
   ggplot(aes(cEOF1, cEOF2)) +
   geom_point()
```


```{r fft2}
fft <- ceofs_larga[, eof[[1]]$left, by = model] %>% 
   sep_ReIm() %>% 
   copy() %>% 
   .[, eof := eof/sd(Mod(eof)), by = .(model, cEOF)] %>%
   .[order(time)] %>% 
   .[, fftspectrum(eof, c(3, 5), B = 0), by = .(model, ensemble, cEOF, part)]
```



(ref:fft-1l-cap) Igual que Figura \@ref(fig:fft-1) pero para el período 1850 -- 2014.

```{r fft-1l, fig.height=8, fig.width=9}
plot_fft(1)
```

(ref:fft-2l-cap) Igual que Figura \@ref(fig:fft-2) pero para el período 1850 -- 2014.

```{r fft-2l, fig.height=8, fig.width=9}
plot_fft(2) +
   coord_cartesian(ylim = c(0, 11)) 
```

