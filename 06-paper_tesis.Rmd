---
title: "paper de la tesis"
author: "Elio Campitelli"
output: 
   powerpoint_presentation:
    # ioslides_presentation:
        fig_height: 5
        fig_width: 11
        reference_doc: ppttemplate.pptx
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Notification
start.time <- unclass(Sys.time())
min.time <- 10
knit_doc <- knitr::knit_hooks$get("document")
knitr::knit_hooks$set(document = function(x) {
   took <- unclass(Sys.time()) - start.time
   if (unclass(Sys.time()) - start.time >= min.time) {
      notify("Done knitting!", 
             paste0("Took ", round(took), " seconds"),
             time = 5)
   }  
   knit_doc(x)
})

knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE, cache.lazy = TRUE,
                      cache.path = "cache/06-paper_tesis",
                      fig.path = "fig/06-paper_tesis",
                      warning = FALSE
                      # dev = "cairo_pdf"
                      )

library(data.table)
library(ggplot2)
library(dplyr)
library(metR) 
library(circular)
library(hrbrthemes)
library(extrafont)
library(patchwork)
library(officer)

knit_error <-  knitr::knit_hooks$get("error")
knitr::knit_hooks$set(error = function(x, options) {
   notify("Error knitting!", time = 5)
   knit_error(x, options)
})


source("scripts/helperfun.R")
# Plot thingys

data.world <- BuildMap(res = 1, smooth = 1)
map.world <- geom_map2(data.world)
map.SH <- geom_map2(data.world[lat %b% c(-90, 20)], color = "gray20")


pres <- ReadNetCDF("DATA/srfp.mon.mean.nc")
pres.mean <- pres[, .(pres = median(pres)), by = lat]
pres.mean <- rbind(data.table(lat = 0.0, pres = Inf), 
                   pres.mean, 
                   data.table(lat = -90.0, pres = Inf))
surface <- geom_polygon(data = pres.mean, aes(y = pres), fill = "white", 
                        alpha = 1, color = "gray30", size = 0.5)
pres <- pres[, .(pres = mean(pres)), by = .(lon, lat)]

# From https://github.com/hrbrmstr/hrbrthemes/issues/18
d <- read.csv(extrafont:::fonttable_file(), stringsAsFactors = FALSE)
d[grepl("Light", d$FontName),]$FamilyName <- font_rc_light
write.csv(d,extrafont:::fonttable_file(), row.names = FALSE)
extrafont::loadfonts()

theme_elio <- theme_minimal(base_size = 11) +
   theme(
      text = element_text(family = font_rc),
      legend.position = "bottom", legend.box = "vertical",
      panel.spacing.y = unit(5, "mm"),
      panel.spacing.x = unit(5, "mm"),
      legend.spacing = unit(2, "mm"),
      plot.margin = grid::unit(rep(3, 4), "mm"),
      legend.title = element_blank(),
      legend.box.spacing = unit(3, "mm"),
      legend.margin = margin(t = -5),
      panel.grid = element_line(color = "gray50", size = 0.2, linetype = 3),
      panel.ontop = TRUE)
theme_set(theme_elio)
update_geom_defaults(metR:::GeomTextContour, list(family = font_rc))

update_geom_defaults("contour2", list(color = "black"))
update_stat_defaults("contour2", aes(linetype = factor(-sign(..level..))))

options(ggplot2.continuous.fill = "viridis", 
        ggplot2.continuous.color = "viridis")

coord_quickmap <- function(..., ylim = c(-90, -15)) {
   ggplot2::coord_quickmap(ylim = ylim, ...) 
} 

geom_contour_ <- function(..., gap = 0, rotate = FALSE) {
   if (gap != 0) {
      list(geom_contour2(..., gap = gap),
           geom_text_contour(..., rotate = rotate))
   } else {
      geom_contour2(...)
   }
}

# For vertical cross-sections
coord_latlev <- function(ratio = 20, ...) coord_fixed(ratio = ratio, ...)
coord_lonlev <- function(ratio = 20*4, ...) coord_fixed(ratio = ratio, ...)

lev.breaks <- c(1000, 500, 300, 200, 100, 50, 10)

season <- function(...) {
   metR::season(..., lang = "en")
}


## Options for generating ppt output
ppt <- FALSE
pptfile <- "figuras.pptx"
ppttemplate <- "ppttemplate.pptx"
# Initial ppt
if (ppt == TRUE){
   my_pres <- read_pptx(ppttemplate)
   print(my_pres, pptfile)   
}

# Add a plot to ppt 
knit_plot <- knitr::knit_hooks$get("plot")

knitr::knit_hooks$set(plot = function(x, options) {
   if (ppt == TRUE) {
      # print(options)
      if (inherits(last_plot(), "gg")) {
         read_pptx(pptfile)  %>%
            add_slide(layout = "figure", master = "Office Theme") %>%
            ph_with_gg(last_plot(), type = "pic") %>%
            ph_with_text(options$fig.cap, type = "body") %>%
            print(pptfile)
         set_last_plot(NULL)   # remove last_plot()
      } else {
         read_pptx(pptfile ) %>%
            add_slide(layout = "figure", master = "Office Theme") %>%
            rvg::ph_with_vg(code = eval(parse(text = options$code)), 
                            type = "pic") %>%
            ph_with_text(options$fig.cap, type = "body") %>% 
            print(pptfile)
      }
   }
   knit_plot(x, options)
})

# Turn off cache for figures
knitr::opts_hooks$set(fig.cap = function(options) {
   if (ppt == TRUE) options$cache <- FALSE
   options
})

```

```{r read-ncep}
subset.time <- lubridate::as_datetime(c("1979-12-01", "2015-12-01"))
ncep.f <- memoise::memoise(function(lat = -90:40, 
                                    lon = 0:360,
                                    time = lubridate::as_datetime(c("1979-12-01",
                                                                    "2015-12-01")),
                                    level = 10:1000,
                                    vars = "gh"){
   subset <- list(lat = lat, lon = lon, level = level,
                  time = time)
   n <- ReadNetCDF("DATA/NCEP Reanalysis/hgt.mon.mean.nc", vars = c(gh = "hgt"),
                   subset = subset) %>% 
      setnames(., c("level"), c("lev"))
   if ("u" %in% vars) {
      n[, u := ReadNetCDF("DATA/NCEP Reanalysis/uwnd.mon.mean.nc", out = "vector",
                          subset = subset)[[1]]] 
   }
   if ("v" %in% vars) {
      n[, v := ReadNetCDF("DATA/NCEP Reanalysis/vwnd.mon.mean.nc", out = "vector",
                          subset = subset)[[1]]]
   }
   n[, time := as.Date(time[1]), by = time]
   return(n)
}, cache = memoise::cache_filesystem(".rcache"))
ncep <- ncep.f()
```


### Selección de figuras para paper


```{r calc-fourier1}
rect.annotation <- data.frame(latmin = -65, latmax = -40,
                              levmin = 100, levmax = 700, 
                              k = 3)
gh.season <- ncep[, .(gh = mean(gh)), by = .(lat, lon, lev, season(time))]  
ncep.qs <- ncep[, meanfun(gh, time, function(x) FitWave(x, 3)$amplitude),
                by = .(lat, lev, season(time))]
```

```{r ampl-ncep, fig.cap = "Stationarity of QS3 (shaded, defined in text) and fourier amplitude of geopotential height (contours)."}
binwidth.ampl <- 10
binwidth.stat <- 0.1
ggplot(ncep.qs[lat <= 0], aes(lat, lev)) +
   geom_contour_fill(aes(z = fun.mean/mean.fun), breaks = MakeBreaks(binwidth.stat),
                     na.rm = TRUE) + 
   geom_contour2(aes(z = fun.mean/mean.fun), breaks = 0.5, linetype = 2) +
   geom_contour2(aes(z = fun.mean), binwidth = binwidth.ampl) +
   geom_text_contour(aes(z = fun.mean), color = "black", 
                     binwidth = binwidth.ampl,
                     stroke.color = "#2B828C", stroke = 0.15) +
   surface +
   geom_index.region(rect.annotation) +
   # scale_fill_viridis_c(name = "Amplitud (escala logarítmica)", 
   #                      trans = "log2",
   #                      breaks = breaks,
   #                      labels = round(breaks, 1),
   #                      guide = guide_colorstrip_bottom(),
   #                      option = "D") +
   scale_fill_viridis_c(guide = guide_colorstrip_bottom(),
                        option = "D",
                        breaks = MakeBreaks(binwidth.stat)) +
   scale_y_level(breaks = lev.breaks) +
   scale_x_latitude(name = "latitude", trans = "reverse", ticks = 15) +
   coord_latlev() +
   facet_wrap( ~ season) 
```

```{r calc-index}
lats.index <- c(-65, -40)
levs.index <- c(100, 700)
index <- ncep[lat %b% lats.index & lev %b% levs.index,
              qs3.index(gh, lat, lev), 
              by = time]
```


::: notes

(En la tésis no tengo demasiado texto sobre ésta figura; principalmente la compara con el campo de r2 que no voy a mostrar.)

The amplitude of wave 3 can be computed via Fourier decomposition of the mean seasonal field (*AM* method) or by computing the mean amplitude of the instantaneous --monthly-- fields (*MA* method). The ratio MA/AM can be used as a meassure of the stationarity of the zonal wave 3 since a perfectly stationary wave (withouth change in phase) would have a ratio equal to 1 and a completely unstationary wave (with completely random phase) would have a ratio close to zero... 

The amplitude of QS3 achieves it's maximum at near 200hPa and 50°S in all seasons but with important changes in it's vertical extent. During austral winter and autum, wave 3 amplitude extends up to the higest model levels while it remains restricted to the stratosphere during spring and summer. In general, the high amplitudes are colocated with areas of high stationarity, although this metric is maximized at lower levels with the exception of spring. While the mean wave amplitude during this season is high (not shown), stationarity is low in the midlatitudes and specially in the high stratosphere. This is due primarily by the behaviour during november, when high phase variance means that wave 3 cannot be considered stationary. 

:::

```{r destructive}
copy(index) %>% 
    .[, meanphase := mean(phase*3)/3, by = month(time)] %>% 
    .[, interf := as.numeric(phase - meanphase)] %>% 
    .[, .(percent_destructive = mean(abs(interf) %between% (c(1/3, 2/3)*120*pi/180))*100,
          phase_sd = sd.circular(phase*3)*180/pi/3),
          by = season(time)] %>% 
   
    # knitr::kable(caption = "Porcentaje de meses con interferencia destructiva",digits = 3,
    #              col.names = c("Season", "Proportion of \ndestructive interference",
    #                            "Phase standard deviation"),
    #              format = "markdown") %>% 
   identity()
```


```{r calc-gh3-season}
gh.season <- gh.season[, qs3 := FilterWave(gh, 3), by = .(lat, lev, season)]
```

```{r gh3-season, fig.cap = "Wave 3 component of the geopotential field of each season at 200hPa."}
binwidth <- 10
ggplot(gh.season[lev == 200], aes(lon, lat)) +
   geom_contour_fill(aes(z = qs3), breaks = AnchorBreaks(0, binwidth, 0), 
                     xwrap = c(0, 360)) +
   geom_contour2(aes(z = qs3), breaks = AnchorBreaks(0, binwidth, 0),
                 xwrap = c(0, 360)) +
   map.SH +
   scale_s_map(ylim = c(-90, 20)) +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), 
                        name = "QS3",
                        guide = guide_colorstrip_bottom()) +
   facet_wrap(~season, ncol = 2) +
   coord_quickmap()
```

::: notes

The reconstructed QS3 field at 200hPa show the expected maximum at 50°S and the anual cycle in its phase already observed in previous studies. It also shows an easterly inclination of the systems evident in summer but absent in winter, suggesting that the QS3 might be related to southerly transport of momentum. 

:::


```{r qs3-season-cut, fig.cap = "Mean wave 3 component of geopotential height between 65°S and 35°S"}
cutlats <- c(-65, -35)
binwidth <- 5
ggplot(gh.season[lat %between% cutlats, .(qs3 = mean(qs3)), 
                   by = .(lon, lev, season)], 
       aes(lon, lev)) +
   geom_contour_fill(aes(z = qs3), breaks = AnchorBreaks(0, binwidth, 0)) +
   geom_contour3(aes(z = qs3), breaks = AnchorBreaks(0, binwidth, 0)) +
   scale_y_level(breaks = lev.breaks) +
   scale_x_longitude(name = "lon") +
   scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), 
                        name = "QS3",
                        guide = guide_colorstrip_bottom()) +
   facet_wrap(~season, ncol = 2) 
```

::: notes

The vertical strucure of the QS3 shows that the expected seasonal cycle in vertical extent is followed by a slight inclination of the disturances. 

Taken together, this suggests a mix of baroclinic and barotropic processes related to the QS3. The former, more important during summer and the the latter dominating in winter. (Esto se debería ver con la energética)

:::


```{r boxplot-index, fig.cap = "Seasonal cicle of QS3 index."}
ggplot(index, aes(factor(month(time)), amplitude)) +
   # geom_violin() +
   geom_boxplot(outlier.alpha = 0, fill = "gray95") +
   geom_sina(alpha = 0.5, size = 0.7) +
   scale_x_discrete(name = "Mes", labels = month.abb) +
   scale_y_continuous(name = "Amplitud") +
   theme(panel.grid.major.x = element_blank())
```

::: notes

ZW3 activiy exhibits a clear anual cycle with higher amplitude during the austral winter months and lower amplitude during the summer months.

:::


```{r read-psi}
psi.file <- "DATA/NCEP Reanalysis/psi.mon.mean.nc"
levs <-  ReadNetCDF(psi.file, out = "vars")$dimensions$level
levs <- levs[levs %~% 0.21]
stream <- ReadNetCDF(psi.file, subset = list(lat = -90:40,
                                             level = levs,
                                             time = subset.time)) %>% 
    # setnames(c("level", "time"), c("lev", "date")) %>% 
    .[, psi.z := Anomaly(psi), by = .(lat, time)]
stream[, time := as.Date(time[1]), by = time]
```

```{r calc-regrs}
# lats <- stream[time == time[1], unique(round(lat, 3))]
# lons <- stream[time == time[1], unique(round(lon, 3))]

stream.reg <- stream[, .(lon, lat, time, psi.z)] %>% 
    .[index, on = "time"] %>% 
    .[, FitLm(psi.z, amplitude = amplitude/sd(amplitude), phase = phase, 
              se = TRUE), 
      by = .(lat, lon, month(time))] %>% 
    .[term == "amplitude"] %>% 
    # .[, Interpolate(estimate ~ lon + lat, x.out = lons, y.out = lats),
    #                      by = month] %>%
    .[, psi.z := estimate] %>% 
    .[, c("f.x", "f.y") := WaveFlux(.SD), by = .(month)] %>% 
    .[complete.cases(.)]

gh.reg <- ncep[lev == 200][index, on = "time"] %>% 
    .[, FitLm(gh, amplitude = amplitude/sd(amplitude), phase), 
      by = .(lat, lon, month(time))] %>% 
    .[term == "amplitude"]
```


```{r regr-psi-ncep, fig.cap = "Regresión de altura geopotential en 200hPa con el índice de QS3 estandarizado y flujos de actividad de onda calculados a partir de la regresión de psi con A3 estandarizado en sigma = 0.2101."}
months <- 1:12 # c(1, 3, 4, 7, 8, 12)
binwidth <- 10
stream.g <- stream.reg[lat <= 0 & month %in% months] 
gh.g <- gh.reg[month %in% months]

ggplot(gh.g, aes(lon, lat)) +
    geom_contour_fill(aes(z = estimate), xwrap = c(0, 360),
                      breaks = AnchorBreaks(0, binwidth, 0)) +
    geom_contour2(aes(z = estimate, linetype = factor(-sign(stat(level)))), 
                  breaks = AnchorBreaks(0, binwidth, 0), xwrap = c(0, 360), 
                  size = 0.1) +
    geom_streamline(aes(dx = f.x, dy = f.y), skip = 4, min.L = 3,
                    xwrap = c(0, 360),
                    res = 4, L = 3, arrow.length = 0.2, size = 0.2,
                data = stream.g) +
    map.world +
    scale_s_map() +
    scale_fill_divergent(breaks = AnchorBreaks(0, binwidth, 0), 
                         guide = guide_colorstrip_bottom()) +
    coord_quickmap(ylim = c(-90, -15)) +
    facet_wrap(~month, dir = "h",
               labeller = labeller(month = month.abb)) +
    theme(panel.spacing.y = unit(0, "lines"))
```

