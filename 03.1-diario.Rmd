---
title: "03.1 - usar datos diarios"
author: "Elio Campitelli"
output:
   ioslides_presentation:
      fig_height: 5.5
      fig_width: 10.5
      smaller: yes
      widescreen: yes
      cache: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      cache = TRUE, 
                      cache.lazy = TRUE,
                      fig.path = "share/03.1-diario/",
                      warning = FALSE)

library(data.table)
library(ggplot2)
library(dplyr)
library(metR) 
library(WaveletComp)
# library(patchwork)
library(circular)
library(hrbrthemes)
library(extrafont)

source("scripts/helperfun.R")
# Plot thingys

data.world <- BuildMap(res = 1, smooth = 1)
map.world <- geom_map2(data.world)
map.SH <- geom_map2(data.world[lat %b% c(-90, 20)], color = "gray20")


pres <- ReadNetCDF("DATA/srfp.mon.mean.nc")
pres.mean <- pres[, .(pres = median(pres)), by = lat]
pres.mean <- rbind(data.table(lat = 0.0, pres = Inf), 
                   pres.mean, 
                   data.table(lat = -90.0, pres = Inf))
surface <- geom_polygon(data = pres.mean, aes(y = pres), fill = "white", 
                        alpha = 1, color = "gray30", size = 0.5)
pres <- pres[, .(pres = mean(pres)), by = .(lon, lat)]

# From https://github.com/hrbrmstr/hrbrthemes/issues/18
d <- read.csv(extrafont:::fonttable_file(), stringsAsFactors = FALSE)
d[grepl("Light", d$FontName),]$FamilyName <- font_rc_light
write.csv(d,extrafont:::fonttable_file(), row.names = FALSE)
extrafont::loadfonts()

theme_elio <- theme_minimal(base_size = 11) +
   theme(
      text = element_text(family = font_rc),
      legend.position = "bottom", legend.box = "vertical",
      panel.spacing.y = unit(5, "mm"),
      panel.spacing.x = unit(5, "mm"),
      legend.spacing = unit(2, "mm"),
      plot.margin = grid::unit(rep(3, 4), "mm"),
      legend.title = element_blank(),
      legend.box.spacing = unit(3, "mm"),
      legend.margin = margin(t = -5),
      panel.grid = element_line(color = "gray50", size = 0.2, linetype = 3),
      panel.ontop = TRUE)
theme_set(theme_elio)
update_geom_defaults(metR:::GeomTextContour, list(family = font_rc))

update_geom_defaults("contour2", list(color = "black"))
update_stat_defaults("contour2", aes(linetype = factor(-sign(..level..))))

options(ggplot2.continuous.fill = "viridis", 
        ggplot2.continuous.color = "viridis")

coord_quickmap <- function(..., ylim = c(-90, 20)) {
   ggplot2::coord_quickmap(ylim = ylim, ...) 
} 

geom_contour_ <- function(..., gap = 0, rotate = FALSE) {
   if (gap != 0) {
      list(geom_contour2(..., gap = gap),
           geom_text_contour(..., rotate = rotate))
   } else {
      geom_contour2(...)
   }
}

# For vertical cross-sections
coord_latlev <- function(ratio = 20, ...) coord_fixed(ratio = ratio, ...)
coord_lonlev <- function(ratio = 20*4, ...) coord_fixed(ratio = ratio, ...)

lev.breaks <- c(10, 30, 100, 200, 500, 1000)
```


---

Datos diarios de anomalía zonal de altura geopotential con un promedio móvil de 
30 días y filtrando la onda 1. 

---

<!-- ```{r, cache = FALSE} -->
<!--  f <- memoise::memoise(function() { -->
<!--     gh <- ReadNetCDF("DATA/hgt.daily_2000.nc", -->
<!--                      vars = c(gh = "hgt"), key = TRUE) -->
<!--     setnames(gh, "level", "lev") -->
<!--     gh[, gh1 := FilterWave(gh, 0:1), by = .(time, lat)] -->
<!--     gh[, gh1roll := RcppRoll::roll_mean(gh1, 30, fill = NA), by = .(lon, lat)] -->

<!--  }, cache = memoise::cache_filesystem(".rcache")) -->
<!--  gh <- f() -->
<!-- ``` -->


```{r}
lats.eof <- c(-80, -30)
gh <- ReadNetCDF("DATA/hgt.daily_2000.nc", subset = list(lat = lats.eof),
                 key = TRUE, vars = c(gh = "hgt"))
setnames(gh, "level", "lev")
gh[, gh1 := FilterWave(gh, 0:1), by = .(time, lat)]
gh[, gh1roll := RcppRoll::roll_mean(gh1, 30, fill = NA), by = .(lon, lat)]

qs.eof <- copy(gh[!is.na(gh1roll)])[ , gh := gh1roll*sqrt(cos(lat*pi/180))] %>%
   .[, gh := resid(.lm.fit(cbind(1, time), gh)), 
     by = .(lon, lat)]
qs.eof <- EOF(data = qs.eof, gh ~ time | lon + lat, n = 1:10)
```

```{r}
qs.eof$left %>% 
   dcast(time ~ PC, value.var = "gh") %>% 
   .[, angle := atan2(PC2, PC1)] -> angle

gh[!is.na(gh1roll), angle := angle$angle*180/pi, by = .(lon, lat)]

N <- 10

plyr::round_any

gh[, rangle := plyr::round_any(angle, 3)]

gh[, .(gh = mean(gh1)), by = .(lon, lat, rangle)] %>% 
   .[!is.na(rangle)] -> fields
```

```{r}
binwidth <- 20
ggplot(fields, aes(lon, lat)) +
   geom_contour_fill(aes(z = gh, frame = factor(rangle)), circular = "x",
                     breaks = AnchorBreaks(0, binwidth, 0))  +
   geom_vline(aes(frame = factor(rangle), 
                  xintercept = ConvertLongitude(rangle, 180))) +
   map.SH +
   scale_s_map(ylim = c(-90, -30)) +
   scale_fill_divergent() +
   coord_polar() -> g

gganimate::gganimate(g, "angle.gif", interval = 0.2)
```


```{r scree, fig.cap = "Valores principales"}
n <- length(unique(gh$time))
k <- sqrt(2/n)
ggplot(qs.eof$sdev, aes(as.numeric(PC), sd)) +
   geom_point() +
   geom_line() +
   geom_errorbar(aes(ymax = sd + 2*sd*k, ymin = sd - 2*sd*k), width = 0.5) +
   scale_x_continuous(breaks = 1:10) 
```


---

```{r eof, fig.cap = "EOFs"}
ggplot(qs.eof$right, aes(lon, lat)) + 
   geom_contour_fill(aes(z = gh), breaks = AnchorBreaks(0, 0.01, 0)) +
   map.SH +
   scale_s_map(ylim = c(-90, -20)) +
   scale_fill_divergent() +
   facet_wrap(~PC)  +
   coord_quickmap(ylim = c(-90, -20)) 
```

---

```{r cor, fig.cap = "Correlograma entre PC1 y PC2"}
lags <- -60:60
qs.eof$left %>% 
   dcast(time ~ PC, value.var = "gh") %>% 
   .[, lapply(lags, function(x) {
      type <- ifelse(x > 0, "lead", "lag")
      cor(PC1, shift(PC2, abs(x), type = type), 
          use = "complete.obs")})] %>% 
   melt() %>% 
   .[, variable := lags] %>% 
   ggplot(aes(lags, value)) +
   geom_line() +
   geom_hline(yintercept = 0) +
   scale_y_continuous("Correlation") +
   scale_x_continuous("Lag (PC1 leads PC2)", JumpBy(lags, 10))
```

<div class = "notes"> 
El autocorrelograma tiene una estructura de una onda propagante, aunque la amplitud de las correlaciones es muy baja. Si no se hace el promedio móvil de 30 días, también aparece, pero con más intensidad. 
</div> 


---

```{r dendo, fig.cap = "Dendogram"}
qs.eof$left %>% 
   .[qs.eof$sdev, on = c("PC")] %>% 
   .[, .(value = mean(gh*sd)), by = .(PC, month(time))] %>%
   dcast(month ~ PC, value.var = "value") %>% 
   .[, plot(hclust(dist(.SD[, -1])),
            labels = month.abb, hang = -1)] 
```


---

```{r}
subset <- list(lat = -90:40, level = 200, 
               time = lubridate::as_datetime(c("1979-12-01", "2015-12-01")))
ncep <- ReadNetCDF("DATA/hgt.mon.mean.nc", vars = c(gh = "hgt"),
                   subset = subset) %>% 
   setnames(., c("level"), c("lev"))

region <- expand.grid(lat = c(-65, -40),
                      lev = c(100, 700))
lats.eof <- c(-80, -30)
copy(ncep[lev == 200 & lat %between% lats.eof]) %>%
   .[, gh.minus := FilterWave(gh, k = 0:1), by = .(lat, time, lev)] %>% 
   .[, gh := gh.minus*sqrt(cos(lat*pi/180))] %>%
   .[, gh := resid(.lm.fit(cbind(1, time), gh)), 
     by = .(lon, lat)] %>% 
   EOF(data = ., gh ~ time | lon + lat, n = 1:10, rotate = TRUE) -> qs.eofm
remove(ncep)
```


```{r eof-compare, fig.cap = "Comparación de la PC utilizando datos diarios (negro) y utilizando datos mensuales (rojo). Ambas están estandarizadas por sus respectivos desvios estándar."}
ggplot(CutEOF(qs.eof$left, 1:2)[, gh := gh/sd(gh), by = PC], aes(time, gh)) + 
   geom_line() +
   geom_line(data = CutEOF(qs.eofm$left, 1:2)[, gh := gh/sd(gh), by = PC], color = "red") +
   scale_x_datetime(limits = range(qs.eof$left$time)) +
   facet_wrap(~PC, ncol = 1)
```

<div class = "notes"> 
Ambas series son muy similares por lo que las regresiones usando una u otra también van a serlo. Para confirmarlo necesitaría los datos diarios de las otras variables. 
</div> 

---

```{r, cache = FALSE}
subset <- list(lat = -90:40)
f2 <- memoise::memoise(function(qs.eof) {
   olr <- ReadNetCDF("DATA/olr.daily.nc", vars = "olr", subset = subset, key = TRUE)
   olr[, olr.a := Anomaly(olr), by = .(lon, lat, data.table::yday(time))]
   olr[, season := qs.trim(data.table::month(time[1])), by = time]
   setkey(qs.eof$left, time)
   
   qs.eof$left %>%
      .[, gh := gh/sd(gh), by = .(PC)] %>% 
      .[as.numeric(PC) %in% 1:2] %>% 
      dcast(time ~ PC, value.var = "gh") %>%
      setkey(time) %>% 
      .[olr, on = "time"] %>%
      .[!is.na(PC1)] -> olr
   return(olr)
}, cache = memoise::cache_filesystem(".rcache"))
olr <- f2(qs.eof)
```


```{r calc-olr.regr}
olr[!is.na(qs.trim(time)), 
    FitLm(olr.a, PC1, PC2, se = TRUE),
    by = .(lon, lat, season)] %>% 
   .[regressor != "mean"] -> olr.regr
```

```{r olr-regr, fig.cap = "Regression between OLR and PCs (diario)"}
binwidth <- 2.5
ggplot(olr.regr[regressor != "ONI"], aes(lon, lat)) +
   geom_contour_fill(aes(z = estimate), breaks = AnchorBreaks(0, binwidth, 0),
                     circular = "x") +
   geom_contour3(aes(z = sign(estimate)*as.numeric(abs(estimate) > se*2),
                     linetype = factor(sign(..level..))),
                 breaks = c(-0.5, 0.5), circular = "x") +
   stat_subset(aes(subset =  abs(estimate) > se*2), geom = "point",
               alpha = 0.5, color = "black", size = 0.05,
               data = olr.regr[regressor != "ONI" & lon %in% JumpBy(unique(lon), 2) &
                                  lat %in% JumpBy(unique(lat), 2)]) +
   map.SH +
   scale_s_map() +
   scale_fill_gradient2(breaks = AnchorBreaks(0, binwidth, 0),
                        guide = guide_colorstrip_bottom()) +
   coord_quickmap() +
   facet_grid(season~regressor)
```

---

Con datos diarios, quizás pueda ver si las correlaciones lageadas me dan una idea de 
causa-efecto (anomalía de olr -> PC1).

Haco la olr media en la región El Niño 3.4 (5S-5N, 170O-)

## Correlación con la olr en El Niño 3.4


```{r}
EN34 <- function(lon, lat) {
   lat %between% c(-5, 5) & lon %between% c(190, 240)
}

enso <- olr[lat %between% c(-5, 5) & lon %between% c(190, 240)] %>% 
   .[ , .(anom = mean(olr.a), full   = mean(olr)), 
      keyby = time] %>% 
   melt(id.vars = "time", value.name = "olr", variable.name = "type")

qs.eof$left %>%
   # .[, gh.a := Anomaly(gh), by = .(yday(time), PC)] %>%
   .[as.numeric(PC) %in% 1:2] %>% 
   dcast(time ~ PC, value.var = "gh") %>%
   setkey(time) %>% 
   .[enso, on = "time"] -> enso
```


```{r enso-cor}
lag <- 365
lags <- seq(-lag, lag)

enso %>% 
   .[, lapply(lags, function(x) {
      t <- ifelse(x > 0, "lead", "lag")
      cor(PC1, shift(olr, abs(x), type = t), 
          use = "complete.obs")}), by = type] %>% 
   melt(id.vars = "type") %>% 
   .[, lag := lags, by = type] %>% 
   ggplot(aes(lag, value, color = type)) +
   geom_line() +
   geom_hline(yintercept = 0) +
   scale_y_continuous("Correlation") +
   scale_x_continuous("Lag (OLR leads PC1)") +
   scale_color_brewer(palette = "Set1")
```

